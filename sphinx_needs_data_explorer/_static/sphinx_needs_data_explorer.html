<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Sphinx_Needs Data Explorer</title>
        <script src="vis-network/vis-network.min.js"
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="jquery/jquery-3.7.1.min" 
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <link href="select2/select2.min.css" rel="stylesheet" />
        <script src="select2/select2.min.js" 
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="peg/peg-0.10.0.min.js"
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <center>
            <h1></h1>
        </center>
            <center>
            <h1></h1>
        </center>
        <style type="text/css">
            .ack-table {
                width: 100%;
                border-collapse: collapse;
            }
            .ack-th {
                background-color: #4CAF50;
                color: white;
                padding: 10px;
            
            }
            .ack-th, .ack-td  .at-th, .at-td {
                border: 1px solid #dddddd;
                padding: 8px;
                text-align: left;
                white-space: nowrap;
                overflow: auto;
            }
            .att-td {
                /* font-family: Consolas, Menlo, Courier, "Lucida Console", Monaco, monospace; */
                font-family: 'Source Code Pro', monospace;
                border: 1px solid #dddddd;
                padding: 8px;
                text-align: left;
                white-space: nowrap;
                overflow: auto;
            }

            /* Define column widths in percentage */
            .at-th:nth-child(-n+3), .at-td:nth-(-n+3) {
                width: 10%;
            }

            .at-th:nth-child(4), .at-td:nth-child(4) {
                width: 50%;
            }

            .typedrop {
                font-size: 22px;
            }
            .bigdrop {
                width: 1000px !important;
                margin-top: +20px;
                margin-left: -600px;
                font-size: 22px;
            }

            .bigdropFilter {
                width: 1000px !important;
                margin-top: +20px;
                margin-left: -400px;
                font-size: 22px;
            }

            .select2-container--default .select2-results>.select2-results__options{
                max-height: 500px !important;
            }

            .select2-selection__placeholder {
                font-size: 22px;
            }
            
            .select2-search__field {
                font-size: 22px;
            }
            
            .select2-selection__rendered {
                font-size: 22px;
            }
            #tooltip-window {
                width: auto;
                margin: 15px 5px;
                margin-right: 20px;
            }
            #mynetwork {
                /* position: relative; */
                width: auto;
                height: 86%;
                margin: 15px 5px;
                /* justify-content: space-between; */
                margin-right: 20px;
                background-color: #ffffff;
                /* border: 1px solid lightgray; */
                /* position: relative; */
                /* float: left; */
            }
    
            .ib {
                display: inline-block;
                /* border: 1px solid #ccc; */
            }
    
            .row {
                display: flex;
                width: auto;
                /* flex-direction: row; */
                /* grid-column-gap: 10px; */
                margin: 5px 5px;
                height: 50px;
                /* justify-content: space-between; */
                margin-right: 20px;
                border-radius: 4px;
                column-gap: 0px;
                justify-content: center;
                align-items: center;
                background-color: rgb(45, 43, 43);
            }
            .row>div,
            .row>select,
            .row>input,
            .row>span
             {
                font-size: 22px;
                margin: 5px 5px;
                height: 30px;
                border: none;
            }
            .row>button
             {
                font-size: 22px;
                margin: 5px 5px;
                height: 30px;
                border: none;
            }

            #display-needs-count {
                display: flex;
                flex: 1 20%;
                border-radius: 4px;
                color: white;
                vertical-align: middle;
                justify-content: center;
                align-items: center;
                text-align: center;
                min-width: 200px;
                white-space: nowrap; 
                background-color: rgb(23, 70, 210);
            }
    
            #select-type {
                flex: 1 5%;
                border-radius: 4px;
                color: white;
                background-color: rgb(23, 70, 210);
            }
    
            #select-need-id {
                flex: 1 25%;
                max-width: 25%;
                font-size: 22px;
                border-radius: 4px;
                color: white;
                background-color: rgb(23, 70, 210);
            }
            #select-filter {
                flex: 1 10%;
                font-size: 22px;
                border-radius: 4px;
            }
            .input-inactive {
                position: relative;
                flex: 1 14%;
                max-width: 15% important;
                font-size: 22px;
                border-radius: 4px;
                color: white;
                /* padding: 10px; */
                /* white-space: nowrap; */
                white-space: nowrap; 
                text-overflow: ellipsis; 
                overflow: hidden;
                padding-left: 10px;
                padding-right: 10px;
                background-color: rgb(23, 70, 210);
            }
            .input-active {
                display: flex;
                color: white;
                background-color: rgb(90, 101, 128);
                /* max-width: 300px !important;
                width: 300px !important;
                min-width:300px; */
                width: 80% important;
                /* min-width:80%;
                position: absolute; */
                /*margin-top: +95px; */
                /* margin-left: 10px; */
                font-size: 22px;
                transition: all 0.5s ease-in-out;
            }

            #reset,#help {
                flex: 1 5%;
                border-radius: 4px;
                color: white;
                background-color: rgb(23, 70, 210);
            }

            .modal {
                    display: none;
                    /* position: fixed; */
                    padding: 0;
                    margin: 0;
                    /* position: absolute; */
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 80%;
                    height: 100%;
                    background-color: rgba(0, 0, 0, 0.5);
                    align-items: center;
                    justify-content: center;
                    z-index: 2; /* Set z-index higher than the Vis.js network */
                    overflow-y: auto;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                }

                .modal-content {
                    background-color: rgb(230, 228, 228);
                    padding: 20px;
                    border-radius: 8px;
                    box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
                }

                .close {
                    position: absolute;
                    top: 10px;
                    right: 10px;
                    cursor: pointer;
                }
        </style>
    </head>
    <body>
        <div id="helpModal" class="modal">
            <div class="modal-content">
            <span class="close" onclick="closeHelpDialog()">&#88;</span>
                <h2>Acknowledgments</h2>
                This Software utilizes the following copyrighted material, the use of which is hereby acknowledged.<br>                
                <br>
                <table class="ack-table">
                    <thead>
                        <tr>
                            <th class="ack-th">Name</th>
                            <th class="ack-th">Version</th>
                            <th class="ack-th">License</th>
                            <th class="ack-th">Github</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td class="ack-td"><b>sphinx-needs</b></td>
                            <td class="ack-td">2.0.0</td>
                            <td class="ack-td"><a href="https://github.com/useblocks/sphinx-needs/blob/master/LICENSE"><b>MIT</b></a></td>
                            <td class="ack-td"><a href="https://github.com/useblocks/sphinx-needs">https://github.com/useblocks/sphinx-needs</a></td>
                        </tr>
                        <tr>
                            <td class="ack-td"><b>pegjs</b></td>
                            <td class="ack-td">0.10.0</td>
                            <td class="ack-td"><a href="https://github.com/pegjs/pegjs/blob/master/LICENSE"><b>MIT</b></a></td>
                            <td class="ack-td"><a href="https://github.com/pegjs/pegjs">https://github.com/pegjs/pegjs</a></td>
                        </tr>
                        <tr>
                            <td class="ack-td"><b>vis-network</b></td>
                            <td class="ack-td">9.1.9</td>
                            <td class="ack-td"><a href="https://github.com/visjs/vis-network/blob/master/LICENSE-MIT"><b>MIT</b></a></td>
                            <td class="ack-td"><a href="https://github.com/visjs/vis-network">https://github.com/visjs/vis-network</a></td>
                        </tr>
                        <tr>
                            <td class="ack-td"><b>select2</b></td>
                            <td class="ack-td">4.1.0-rc.0</td>
                            <td class="ack-td"><a href="https://github.com/select2/select2/blob/develop/LICENSE.md"><b>MIT</b></a></td>
                            <td class="ack-td"><a href="https://github.com/select2/select2">https://github.com/select2/select2</a></td>
                        </tr>
                        <tr>
                            <td class="ack-td"><b>jQuery</b></td>
                            <td class="ack-td">3.7.1</td>
                            <td class="ack-td"><a href="https://github.com/jquery/jquery/blob/main/LICENSE.txt"><b>MIT</b></a></td>
                            <td class="ack-td"><a href="https://github.com/jquery/jquery">https://github.com/jquery/jquery</a></td>
                        </tr>            
                    </tbody>
                </table>
                <br>
                <hr>
            <h2>Help Information</h2>
                <h3>Keyboard shortcuts</h3>
                <ul>
<!-- 
                    <li>visjs network keyboard shortcuts</li>
                    <ul>
                        <li>arrow-up, arrow-down, arrow-left, arrow-right to move network on screen</li>
                        <li>+/- zoom-in/zoom out</li>
                    </ul>
 -->
                    <li>n(next), p(previous) to navigate through sphinx_need item list</li>
                    <li>l(layout) - to cycle network layout mode</li>
                        <ul>
                            <li>bottom-up hierarchical</li>
                            <li>right-left hierarchical</li>
                            <li>non-hierarchical</li>
                        </ul>
                    <li>v(view) - to cycle network view mode
                        <ul>
                            <li>selected sphinx_need item and all In-neighbours</li>
                            <li>selected sphinx_need item and all Out-neighbours</li>
                            <li>selected sphinx_need item and all InOut-neighbours</li>
                          </ul>
                    </li>
                    <li>b(beginning) of sphinx_need item list</li>
                    <li>e(end) of sphinx_need item list</li>
                </ul>
                <h3>Mouse events</h3>
                <ul>
                    <li>hover over a node shows tooltip</li>
                    <li>a alt-click at node shows detailed node information in popup window, including a link where complete information 
                        can be found</li>
                </ul>
                <h3>The following sphinx_needs attributes are available in your documentation and can be used for filtering</h3>
                <table class="ack-table">
                    <thead>
                      <tr>
                        <th class="ack-th">Name</th>
                        <th class="ack-th">Type</th>
                      </tr>
                    </thead>
                    <tbody id="help-attributes">
                    </tbody>
                </table>
                <h3>Examples of filtering</h3>
                <table class="ack-table">
                    <tbody>
                        <tr>
                            <td class="att-td">'S_\' in id</td>
                        </tr>
                        <tr>
                            <td class="att-td">'arch' in docname</td>
                        </tr>
                        <tr>
                            <td class="att-td">'architecture/architecture-needs'==docname</td>
                        </tr>
                        <tr>
                            <td class="att-td">status in ['open','closed']</td>
                        </tr>
                        <tr>
                            <td class="att-td">(status=='open' && (type in ['req'])) || ('arch' in docname)</td>
                        </tr>
                        <tr>
                            <td class="att-td">title ~ /^Level[ \t]+(?=one)/ #positive lookaheads</td>
                        </tr>
                        <tr>
                            <td class="att-td">title ~ /^Level[ \t]+(?!one)/ #negative lookaheads</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
        <div>
            <div class="row">
                <div id="display-needs-count">
                    Filter matches '0' IDs
                </div>
                <select title="selectType" id="select-type" onchange="handleSelectTypeEvent()" class="select2 select2-container select2-container--bootstrap select2-container--focus">
                </select>
                <input title="customFilter" type="text" id="input" class="input-inactive">
                <select title="selectFilter" id="select-filter" class="select2 select2-container select2-container--bootstrap select2-container--focus">
                    <option value="">Select</option>
                </select>
                <select title="selectNode" id="select-need-id" onchange="handleSelectNodeEvent()" class="select2 select2-container select2-container--bootstrap select2-container--focus">
                    <option value="">Select Sphinx-Needs 'ID'...</option>
                </select>
                <button id="reset" onclick="resetNetwork()">Reset</button>
                <button id="help" onclick="openHelpDialog()">Help</button>
            </div>
            <ul id="suggestions"></ul>
            <div id="tooltip-window" class="tooltip-window"></div>
            <div id="mynetwork"></div>
        </div>
        <script type="text/javascript">
            const extra_options = {{ EXTRA_OPTIONS }};
            var filters = {{FILTERS}};
            const link_types = {{ LINK_TYPES }};
            var networkContainer;
            const autocompletionDelimiters = [" ",",", "[", "("];
            var suggestionsList;
            var autocompletionAttributes;
            var processingInputFilter=false;
            var userInput;
            var startTime;
            var ecounter=0;
            let verbose=false;
            let MIN_ZOOM = 0.1;
            let MAX_ZOOM = 2.0;
            var viewMode=0;
            var textBoxEditingActive=false;
            var lastTextBoxValue="";
            var saveOpt;
            var tmp_nodes;
            var networkData;
            let lastZoomPosition = {x:0, y:0}
            var selectedType;
            var needs;
            var nodes;
            var network=null;
            var container;
            var options, data;
            var filterWasUsed=false;
            var timeoutId = null;
            var gnodes={};
            var children;
            var children_edges;
            var parents;
            var parents_edges;
            var layoutDirection='DU';
            var 
            needsURL = "../needs.json";
            var parser;
            let grammar;
            const traceParser=false;

            function startTimer() {
                startTime = performance.now();
            }

            function stopTimer(msg) {
                const endTime = performance.now();
                console.log(`Execution time of ${msg}`,endTime - startTime);
            }

            class Node {
                constructor(left, right, operand) {
                this.left = left;
                this.right = right;
                this.operand = operand;
                };
                static class(obj) {
                    return new Node(obj.left,obj.right,obj.operand);
                }
                get(node) {
                    return Node.create(node).expand();
                }
                getValue(node) {
                    // console.log('expand():',this);
                    if('type' in node) {
                        if(node['type']=='array')
                            return node.value;
                        else
                            return node.value;
                    } else 
                        return this.get(node)
                }
                expand() {
                    //console.log('expand():',this);
                    //console.log('typeof this.left',typeof this.left);
                    //console.log('typeof this.right',typeof this.right);
                    let lhs='type' in this.left ?
                        this.getValue(this.left):this.get(this.left);
                    let rhs='type' in this.right ? 
                        this.getValue(this.right):this.get(this.right);
                    return `${lhs} ${this.operand} ${rhs}`
                }
                print() {
                    console.log(this.expand());
                }
                cast(node) {
                    return Node.create(node);
                }
                //isObject(node) { return typeof node === "object" }
                isObject(node) { return !('type' in node); }
                evaluate(currentNode) {
                    var ret=false;
                    // console.log(`" --> ${this.operand}"`);
                    switch (this.operand) {
                        case "in_1":
                            ret=(this.right['value'] in currentNode['data']) && 
                                currentNode['data'][this.right['value']].includes(this.left['value']);
                            // console.log(`${this.left} in ${this.right} = ${ret}`);
                            break;

                        case "in_3":
                            ret=(this.left['value'] in currentNode['data']) && 
                                this.right['value'].split(",").includes(currentNode['data'][this.left['value']]);
                            break;
                        case "in_4":
                            ret=(this.right['value'] in currentNode['data']) && 
                                this.left['value'].split(",").some(v=> currentNode['data'][this.right['value']].includes(v))
                            break;
                
                        case "==1":
                            ret=(this.right['value'] in currentNode['data']) && 
                            (currentNode['data'][this.right['value']]==this.left['value']);
                            break;
                        case "==2":
                            ret=(this.left['value'] in currentNode['data']) && 
                            (currentNode['data'][this.left['value']]==this.right['value']);
                            break;

                        case "&&":
                            ret=(
                            (this.isObject(this.left) ? this.cast(this.left).evaluate(currentNode)   : this.left['value']) && 
                            (this.isObject(this.right) ? this.cast(this.right).evaluate(currentNode) : this.right['value'])
                            )
                            //console.log(`${this.left} in ${this.right} = ${ret}`);
                        break;
                        case "||":
                            ret=(
                                (this.isObject(this.left)  ? this.cast(this.left).evaluate(currentNode)  : this.left['value']) ||
                                (this.isObject(this.right) ? this.cast(this.right).evaluate(currentNode) : this.right['value'])
                                )
                            break;
                        case "()":
                            ret=(this.isObject(this.right) ? this.cast(this.right).evaluate(currentNode) : this.right['value']);
                            break;
                        case "()||":
                            ret=(this.isObject(this.left) ? this.cast(this.left).evaluate(currentNode)   : this.left['value']) ||
                                (this.isObject(this.right) ? this.cast(this.right).evaluate(currentNode) : this.right['value']);
                            break;
                        case "()&&":
                            ret=(this.isObject(this.left)  ? this.cast(this.left).evaluate(currentNode)  : this.left['value']) &&
                                (this.isObject(this.right) ? this.cast(this.right).evaluate(currentNode) : this.right['value']);
                            break;
                        case "EOL":
                            ret=true;
                            break;
                        case "~":
                            //console.log(`${this.left} in ${this.right} = ${ret}`);
                            // var re = new RegExp("a|b", "i");
                            var re = new RegExp(this.right['value']);
                            ret=(this.left['value'] in currentNode['data']) && 
                            (currentNode['data'][this.left['value']].match(re));
                            if(ret) {
                                //console.log(currentNode['data'][this.left]);
                            }
                            break;
                        case "~i":
                            //console.log(`${this.left} in ${this.right} = ${ret}`);
                            // var re = new RegExp("a|b", "i");
                            var re = new RegExp(this.right['value'],'i');
                            ret=(this.left['value'] in currentNode['data']) && 
                            (currentNode['data'][this.left['value']].match(re));
                            if(ret) {
                                //console.log(currentNode['data'][this.left]);
                            }
                            break;
                        default:
                            break;
                    }
                    return ret;
                }
            }

            Node.create = function (obj) {
                var field = new Node();
                for (var prop in obj) {
                    if (field.hasOwnProperty(prop)) {
                        field[prop] = obj[prop];
                    }
                }
                return field;
            }

            var absolute = function(rel) { 
                var link = document.createElement("a"); 
                link.href = rel; 
                return (link.protocol + "//" + link.host + link.pathname); 
            }                 

            function expandArrays(a) {
                let o = '';
                for (e of a)
                    o += e.constructor === Array ? expandArrays(e) : e;
                return o;
            }

            function customFilter(key,currentNode,expr) {
                return Node.create(expr).evaluate(currentNode);
            }
            function isValidUrl(string) {
                try {
                    new URL(string);
                    return true;
                } catch (err) {
                    return false;
                }
            }
            function mainx(input) {
                var msg;
                const i=0;
                var testInput = [
                    "'S_' in id",
                    "('S_' in id)&&('3' in id)",
                    "('S_' in id)&&('3' in id)",
                    "'arch' in docname",
                    "'architecture/architecture-needs'==docname",

                    "'arch' in docname",
                    "status in ['open']",
                    "status in ['open','closed']",
                    "status in ['abc','def','ghi']",
                    "(status in ['abc'])",
                    "status in ['abc'] && (status in ['abc'])",

                    "status in ['abc'] && (status in ['abc']) || 'arch' in docname",
                    "(status in ['abc'] && (status in ['abc'])) || 'arch' in docname",
                    "(status in ['abc'] && (status in ['abc'])) || ('arch' in docname)",
                    "((status in ['abc'] && (status in ['abc'])) || 'arch' in docname)",
                    "(status in ['abc'])",
                    "status in ['abc']",
                    "(status in ['abc']) || status in ['abc']",
                    "docname=='architecture/architecture-needs'",
                    "status in ['open','closed']"
                ];
                //const liveInput=false;
                const liveInput=true;
                if(liveInput) {
                    try {
                        console.log(`Parsing input ${i}:!${input}!`);
                        msg = parser.parse(input);
                        console.log(`Success parsing input: ${input} parsed as ${Node.create(msg).expand()}`);
                    } catch (error) {
                        console.log(`Failure parsing input=${msg} ${error}`);
                        msg=null;
                    }
                } else {
                    testInput.forEach(function (input, i) {
                        try {
                            console.log(`Parsing input ${i}:!${input}!`);
                            msg = parser.parse(input);
                            console.log(`Success parsing input: ${input} parsed as ${Node.create(msg).expand()}`);
                        } catch (error) {
                            console.log(`Failure parsing input=${msg} ${error}`);
                            msg=null;
                        }
                    });
                    msg=null;
                }
                return msg;
            }

            function setCurrentTypeSelectionByText(text) {
                $('#select-type option').each(function () {
                    if ($(this).text().trim() === text.trim()) {
                        $('#select-type').val($(this).val()).trigger('change.select2');
                        return false;
                    }
                });
            }

            var urlToFetch=isValidUrl(needsURL)?url=needsURL:absolute(needsURL);

            const queryString = window.location.search;
            const urlSearchParams = new URLSearchParams(queryString);
            const decodedData = Object.fromEntries(urlSearchParams.entries());

            console.log('decodedData -->');
            console.log(decodedData);

            console.log(urlToFetch);
            let fetchRes = fetch(urlToFetch);
            fetchRes.then(res =>  
                res.json()).then(data => {
                    console.log(`project=${data['project']}`);
                    processJSON(data);
                    prepareParser();
                    suggestionsList = document.getElementById("suggestions");
                    initNetwork();
                    handleSelectTypeEvent();
                    if('type' in decodedData && decodedData['type']!=null) {
                        if('filter' in decodedData && decodedData['filter']!=null) {
                            const newText=decodedData['filter']
                            $('#input').val(decodedData['filter']).trigger('change.select2');
                            newOption=findOptionByText($("#select-filter"),newText);
                            if (newOption.length > 0) {
                                //console.log("Option with text '" + newText + "' already exists.");
                                setCurrentSelectionByText(newText);
                            }
                        }
                        setCurrentTypeSelectionByText(decodedData['type']);
                        if('id' in decodedData && decodedData['id']!=null )
                            $('#select-need-id').val(decodedData['id']).trigger('change.select2');
                    }
                }
            ).catch(error => {
                console.log(`Failed featching needs data:${urlToFetch} -> ${error}`);
            });

            type2color= {{TYPE2COLOR}};

            function handleResize() {
                //console.log('HandlingResize');
                network.redraw();
                network.fit({maxZoomLevel:0.4});
            }

            function parse_links(need) {
                links = [];
                for(const link_type of link_types) {
                    if(link_type in need)
                        links=links.concat(need[link_type]);
                }
                return links;
            }

            function convert_text_to_html(text) {
                //Escape special characters to prevent XSS attacks
                escaped_text = encodeURIComponent(text);
                html_text = escaped_text.replace('\n','<br>');
                return html_text;
            }

            function compareByTwoKeys(a,b) {
                const diff1=gnodes[b]['data']['depth']-gnodes[a]['data']['depth'];
                if(diff1!==0)
                    return diff1;
                return gnodes[b]['data']['sum']-gnodes[a]['data']['sum'];
            }            

            var visited = [];
            var stack = [];

            function computeDepth(key) {
                let depth=0;                
                visited.push(key);
                for(const cur of children[key]) {
                    if(cur in needs) {
                        if(!visited.includes(cur))
                            computeDepth(cur);
                        let curDepth=gnodes[cur]['data']['depth']+1;
                        if(depth<curDepth)
                            depth=curDepth;
                    }
                }
                gnodes[key]['data']['depth']=depth;
            }
            
            // Compute max depth from each root node - BEG
            function computeNodeDepth() {
                visited = [];
                stack = [];
                for(let key in gnodes) {
                    if(visited.includes(key))
                        continue;
                    computeDepth(key);
                }
            }

            function _computeNodeSumOfSubnodes(key) {
                let sum=0;                
                visited.push(key);
                for(const cur of children[key]) {
                    if(cur in needs) {
                        if(!visited.includes(cur))
                        _computeNodeSumOfSubnodes(cur);
                        sum+=gnodes[cur]['data']['sum']+1;
                    }
                }
                gnodes[key]['data']['sum']=sum;
            }

            // Compute node's sub-nodes sum
            function computeNodeSumOfSubnodes() {
                visited = [];
                stack = [];
                for(let key in gnodes) {
                    if(visited.includes(key))
                        continue;
                    _computeNodeSumOfSubnodes(key);
                }
            }

            function prepareParser() {
                const firstKey = Object.keys(gnodes)[0];
                console.log(gnodes[firstKey]['data']);
                grammar = `
                    start = expr
                    ws = ws:[ \t]* { return ws.join("").length>0?" ":""}
                    newline = [ \\t\\n\\r]* { return { left: "", right: "", operand: "EOL" } }
                    QuotedString = "'" text:[A-Za-z0-9_/\\-]+ "'" { 
                        return {'value':text.join(""),'location':location(),'type':'qs'};
                    }

                    QuotedStringx = "'" text:[A-Za-z0-9_/\\-]+ "'" { return text.join(""); }

                    LOperator = "&&" / "||"

                    expr =  exprz0 / expr0 / exprz2 / exprz1

                    exprz1="(" ws r:expr ws ")" {
                        return { left: {'value':'','type':'empty'}, right: r, operand: "()" }
                    }
                    
                    exprz2="(" ws l:expr ws ")" ws o:LOperator ws r:expr {
                        return { left:l, right: r, operand: "()"+o }
                    }

                    exprz0= l:expr0 ws o:LOperator ws r:expr {
                        return { left: l, right: r, operand: o }
                    }

                    expr0 =  expr1 / expr2 / expr3 / reg_expr

                    expr3 = q:QuotedString ws "in" ws w:Words {
                        return { left: q, right: w, operand: 'in_1' }
                    }

                    //str_array="[" ws l:listElm ws "]" {return l}
                    
                    str_array="[" ws l:listElm ws "]" {
                        return {'value':l,'location':location(),'type':'array'};
                    }
                    
                    //return {'key':key,'location':location()};
                    expr1_1 = w:Words ws "in" ws l:str_array {
                        return { left: w, right: l, operand: 'in_3' }
                    }

                    expr1_2 = l:str_array ws "in" ws w:Words {
                        return { left: l, right: w, operand: 'in_4' }
                    }
                    
                    expr1 = expr1_1 / expr1_2

                    listElm1=q:QuotedStringx ws c:"," ws l:listElm { return q+c+l }
                    listElm = listElm1 / QuotedStringx

                    expr2_1 = w:Words ws "==" ws q:QuotedString {
                        return { left:w, right: q, operand: '==2' }
                    }        
                    expr2_2 = q:QuotedString ws "==" ws w:Words {
                        return { left:q, right:w, operand: '==1' }
                    }
                    expr2 = expr2_1 / expr2_2

                    reg_expr_pattern = [^/]
                    reg_expr_value=r:$(reg_expr_pattern+) {  
                        return {'value':r,'location':location(),'type':'re'};
                    }
                    
                    //reg_expr = reg_expr_cs / reg_expr_ci
                    case = "i" / ""
                    reg_expr = w:Words ws "~" ws "/" p:reg_expr_value "/" c:case {
                        return { left:w, right:p, operand: '~'+c }
                    }

                    Words
                        = key:$(Letter+) {
                                //const key=text.join("");
                                // console.log(tmp_nodes[0]['data']);
                                var keys=Object.keys(gnodes);
                                if(key.length<=10) {
                                    if(keys.length==0)
                                        error("No needs data available");
                                    if(key in gnodes[keys[0]]['data']) {
                                        /*return "currentNode['data']['"+key+"']";*/
                                        //console.log("location:",location());
                                        return {'value':key,'location':location(),'type':'need-attr'};
                                    }
                                    else
                                        error("Attribute not found in needs:"+key);
                                } else
                                    error("Word does have more than 10 letters");
                        }
                
                    Letter=[A-Za-z_] //{return text.join("")}
                `;
                parser=peg.generate(grammar,traceParser?{trace:true}:{});
            }            
            function processJSON(data) {
                var vkey="";
                Object.keys(data['versions']).forEach(function(key) {
                    vkey=key;
                })
                if(vkey.length==0) {
                    console.log("Failed to find data");
                    return;
                }
                needs=data['versions'][vkey]['needs']
                let nodes=[];
                children={};
                children_edges={};
                parents={};
                parents_edges={};
                gnodes={};
                let typeSet = new Set(['any']);
                for(const key in needs) {
                    if(verbose)
                        console.log(key,needs[key].docname);
                    children[key]=[];
                    children_edges[key]=[];
                    parents[key]=[];
                    parents_edges[key]=[];
                    typeSet.add(needs[key]['type']);
                    var jsonData={'data':{
                        "type"  :       needs[key]['type'],
                        "title" :       needs[key]['title'],
                        "status":       needs[key]['status'],
                        "docname":      needs[key]['docname'],
                        "tags":         needs[key]['tags'],
                        "lineno":       'lineno' in needs[key]?needs[key]['lineno']:1,
                        //"description":  convert_text_to_html(needs[key]['description']),
                        "description":  needs[key]['description'],
                        'id':           needs[key]['id'],
                        "depth" :0,
                        "count" :0,
                        "sum":0
                    }};

                    for(const option of extra_options) {
                        if(option in needs[key])
                            jsonData['data'][option]=needs[key][option]
                    }

                    for(const link_type of link_types) {
                        if(link_type in needs[key])
                            jsonData['data'][link_type]=needs[key][link_type]
                    }

                    jsonData["shape"]='box'
                    jsonData["id"]=needs[key].id
                    jsonData["label"]=needs[key].id
                    //jsonData["size"]= { width: 30, height: 30 } }
                    jsonData["title"]=`id=${needs[key]['id']}\ntype=${needs[key]['type']}\nstatus=${needs[key]['status']}\ntitle=${needs[key]['title']}`
                    jsonData["title-html"]=`<b>type</b>=${needs[key]['type']}<br>`
                    //
                    // gnodes[each]["title-html"]=
                    jsonData["title-html"]=`
                    <table class="ack-table">
                        <thead>
                        <tr>
                            <th class="at-td">id</th>
                            <th class="at-td">type</th>
                            <th class="at-td">status</th>
                            <th class="at-td">title</th>
                            <th class="at-td">docname</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td class="at-td" title="${jsonData["id"]}">${jsonData["id"]}</td>
                            <td class="at-td" title="${jsonData["data"]["type"]}">${jsonData["data"]["type"]}</td>
                            <td class="at-td" title="${jsonData["data"]["status"]}">${jsonData["data"]["status"]}</td>
                            <td class="at-td" title="${jsonData["data"]["title"]}">${jsonData["data"]["title"]}</td>
                            <td class="at-td">
                                <a href="../${jsonData["data"]["docname"]}.html#${jsonData["id"]}"
                                title="${jsonData["data"]["docname"]}.html}">${jsonData["data"]["docname"]}.html#${jsonData["id"]}</a></td>
                        </tr>
                    </tbody>
                    </table>
                    `
                    //
                    if(needs[key].type in type2color) {
                        jsonData["color"]=type2color[needs[key].type];
                    } else {
                        jsonData["color"]='white'
                    }
                    gnodes[key]=jsonData
                }
                
                if(Object.keys(gnodes).length>0) {
                    const firstKey = Object.keys(gnodes)[0];
                    autocompletionAttributes=[];
                    for(const att of Object.keys(gnodes[firstKey]['data']).sort()){
                        if(!['depth','sum','count'].includes(att))  {
                            //$("#help-attributes").append(`<li>'${att}':${typeof gnodes[firstKey]['data'][att]}</li>`);
                            $("#help-attributes").append(`<tr>
                            <td class="att-td">${att}</td>
                            <td class="att-td">${typeof gnodes[firstKey]['data'][att]}</td>
                            </tr>`.replace(/^[\s]+/gm,""))
                            autocompletionAttributes.push(`${att}`);
                        }
                    }
                }

                for(const key in needs) {
                    for(to of parse_links(needs[key])) {
                        if(to in needs) {
                            if(verbose)
                                console.log(to);
                            var jsonData={"arrows":"to","from":key,"to":to};
                            children[to].push(key);
                            children_edges[to].push(jsonData);
                            parents[key].push(to);
                            parents_edges[key].push(jsonData);
                        }
                    }
                }
                let stype=document.getElementById('select-type')
                for(elm of typeSet) {
                    var opt = document.createElement('option');
                        opt.value = elm;
                        opt.innerHTML = elm;
                        stype.appendChild(opt);
                }
                computeNodeDepth();
                computeNodeSumOfSubnodes();
                return;
            }

            function getID(text) {
                const nonSpaceRegex = /\b\S+\b/;
                const firstNonSpaceWord = text.match(nonSpaceRegex);
                if (firstNonSpaceWord)
                    return firstNonSpaceWord[0];
                return "";
            }

            function handleSelectFirstNodeEvent() {
                let svalue=document.getElementById('select-need-id');
                if(svalue.options.length>0 && svalue.selectedIndex!=0) {
                    var $select = $('#select-need-id');
                    $select.prop('selectedIndex',0).trigger('change');
                    var text = $('#select-need-id option:selected').text();
                    console.log('handleSelectNextNodeEvent',svalue.selectedIndex,svalue.options.length,text);
                    drawFilteredGraph(getID(text));
                }
            }

            function handleSelectLastNodeEvent() {
                let svalue=document.getElementById('select-need-id');
                if(svalue.options.length>0 && svalue.selectedIndex!=(svalue.options.length-1)) {
                    var $select = $('#select-need-id');
                    $select.prop('selectedIndex',svalue.options.length-1).trigger('change');
                    var text = $('#select-need-id option:selected').text();
                    console.log('handleSelectNextNodeEvent',svalue.selectedIndex,svalue.options.length,text);
                    drawFilteredGraph(getID(text));
                }
            }

            function handleSelectPrevNodeEvent() {
                let svalue=document.getElementById('select-need-id');
                if(svalue.options.length>0 && svalue.selectedIndex>0) {
                    var $select = $('#select-need-id');
                    $select.prop('selectedIndex', svalue.selectedIndex - 1).trigger('change');
                    var text = $('#select-need-id option:selected').text();
                    console.log('handleSelectNextNodeEvent',svalue.selectedIndex,svalue.options.length,text);
                    drawFilteredGraph(getID(text));
                }
            }

            function handleSelectNextNodeEvent() {
                let svalue=document.getElementById('select-need-id');
                if(svalue.options.length>0 && (svalue.selectedIndex+1)<svalue.options.length) {
                    var $select = $('#select-need-id');
                    $select.prop('selectedIndex', svalue.selectedIndex + 1).trigger('change');
                    var text = $('#select-need-id option:selected').text();
                    console.log('handleSelectNextNodeEvent',svalue.selectedIndex,svalue.options.length,text);
                    drawFilteredGraph(getID(text));
                }
            }

            function handleSelectNodeEvent() {
                let svalue=document.getElementById('select-need-id');
                var text="";
                if(svalue.options.length>0)
                     text = svalue.options[svalue.selectedIndex].text;
                drawFilteredGraph(getID(text));
            }

            function removeNewlinesAndTrimString(str) {
                return str.trim().replace(/\n/g,'');
            }

            function handleSelectTypeEvent() {
                clearFilter();
                let stype=document.getElementById('select-type');
                let type = stype.options[stype.selectedIndex].value;
                let svalue=document.getElementById('select-need-id');
                let tmp_nodes=[]
                var customFilterExpression=null;
                const textBox = document.getElementById('input');
                const userInputText=removeNewlinesAndTrimString(textBox.value);
                if(userInputText.length>0) {
                    if(parser!=null)
                        customFilterExpression=mainx(userInputText);
                }
                if(userInputText.length==0 || userInputText.length>0 && customFilterExpression!=null) {
                    try {
                        for (let each in gnodes) {
                            if(type==='any' || gnodes[each]['data']['type']===type) {
                                if( (customFilterExpression===null) || 
                                    (customFilterExpression!==null && 
                                    customFilter(each,gnodes[each],customFilterExpression))) {
                                    tmp_nodes.push(each);
                                }
                            }
                        }
                    } catch (error) {
                        console.log(`Failure executing eval('${customFilterExpression}') ${error}`);
                    }
                }
                if(tmp_nodes.length>0) {
                    console.log('tmp_nodes');
                    console.log(tmp_nodes[0]);
                    tmp_nodes.sort(compareByTwoKeys);
                } else {
                    console.log('tmp_nodes empty!');
                }
                for (let each of tmp_nodes) {
                    var opt = document.createElement('option');
                    opt.text   = `${each} - ${gnodes[each]["data"]["title"]}`;
                    svalue.appendChild(opt);
                }
                // Change Select List Option Background-Color on Hover in CSS
                // for(option of svalue.options) {
                //     option.style.background = 'color:"red"';
                // }
                //document.getElementById('display-needs-count').innerHTML = `Found '${+counter.toString()}' instances of type ->`;
                /// document.getElementById('display-needs-count').innerHTML = `Filter matches '${+counter.toString()}' IDs`;
                document.getElementById('display-needs-count').innerHTML = `Filter matches '${tmp_nodes.length}' IDs`;
                handleSelectNodeEvent();
            }

            let selectType = function() {
                return function () {
                    let selectedType = arguments[0];
                    handleSelectTypeEvent(selectedType);
                    console.log(selectedProperty)
                }
            }

            function openHelpDialog() {
                document.getElementById('helpModal').style.display = 'block';
            }

            // Close the help dialog
            function closeHelpDialog() {
                document.getElementById('helpModal').style.display = 'none';
            }

            function resetNetwork() {
                network.fit({maxZoomLevel:0.4});
                //network.redraw();
            }

            function clearFilter() {
                $('#select-need-id').val('');
                $('#select-need-id').empty();
            }

            function getInteractionData() {
                return { 
                            hover: true,
                            tooltipDelay:200,
                            navigationButtons: false,
                            selectable:true,
                            zoomView:true,
                            dragView:true,
                            keyboard:{
                                enabled:true
                                // enabled:!textBoxEditingActive
                            }
                        };
            }

            function getDefaultNetworkLayout(layoutDirection='DU') {
                return {
                    autoResize: false,
                    locale: 'en',
                    interaction:getInteractionData(),
                    nodes: {
                        borderWidth:2,
                        borderWidthSelected:4,
                        color: {
                            border:"black"
                        },
                        // size : 15,
                        //font: { align: 'center', valign: 'middle' }
                        font: {'face': 'monospace', 'align': 'center',size: 40, color: "Black"},
                        fixed: {
                                'x': false,
                                'y': true,
                        },
                        heightConstraint: {
                            minimum: 50
                            //maximum: 50
                        },
                        widthConstraint: {
                            minimum: 150,
                            maximum: 200
                        }
                    },
                    edges: {
                        arrows: { to: {enabled: true} },
                        width: 0.01,
                        hoverWidth: 5.0,
                        "color": {
                            "inherit": false
                        },
                        "smooth": {
                            "enabled": false,
                            "type": "horizontal"
                        }
                    },
                    physics: {
                        enabled: false,
                    },
                    configure: {
                        enabled: false,
                        showButton: false,
                        filter: ['layout','physics']
                    },
                    layout: {
                        randomSeed: 1,
                        improvedLayout: false,
                        hierarchical: {
                            enabled: true,
                            sortMethod: 'directed',  // hubsize, directed
                            shakeTowards: 'leaves',  // roots, leaves
                            direction: layoutDirection,   // UD, DU, LR, RL
                            levelSeparation: 350,
                            nodeSpacing: 350,
                            // treeSpacing: 200,
                            blockShifting: false,
                            edgeMinimization: false,
                            parentCentralization: true
                        }
                    }
                };
            }
            function initNetwork() {
                var container = document.getElementById('mynetwork');
                nodes = new vis.DataSet([]);
                edges = new vis.DataSet([]);
                // adding nodes and edges to the graph
                data = {nodes: nodes, edges: edges};

                network = new vis.Network(container, data, getDefaultNetworkLayout());
                saveOpt = { 
                    interaction: JSON.parse( JSON.stringify( network.interactionHandler.options ) ) 
                };

                networkData=network.body.data;
                network.on('select', function(selection){
                    let selectedNodeIds = selection.nodes; // array of selected node's ids
                    let selectedNodes = nodes.get(selectedNodeIds); // retrive node objects from dataSet object
                    //document.getElementById('tooltip-window').innerHTML = selectedNodes[0]['title-html'];
                });

                network.on('deselectNode', function (properties) {
                    //document.getElementById('tooltip-window').innerHTML = '';
                });

                network.on("doubleClick", function (properties) {
                    var ids = properties.nodes;
                    if(ids.length==0) {
                        return
                    }
                    var clickedNodes = nodes.get(ids);
                    var pnode=clickedNodes[0]
                    drawCurrentSelection(pnode);
                    return;
                });
                
                network.on('click', function (properties) {
                    suggestionsList.innerHTML = "";
                    $('#input').removeClass('input-active').addClass('input-inactive');
                    var oEvent = properties.event.srcEvent;
                    if(properties.nodes.length>0) {
                        if(oEvent.shiftKey) {
                            var ids = properties.nodes;
                            if(ids.length==0) {
                                return
                            }
                            var clickedNodes = nodes.get(ids);
                            var pnode=clickedNodes[0]
                            drawCurrentSelection(pnode);
                            return;
                        }
                        if(oEvent.altKey) {
                            var id = properties.nodes[0];
                            var clickedNode = nodes.get(id);
                            //document.getElementById('tooltip-window').value     = clickedNode['title'];
                            document.getElementById('tooltip-window').innerHTML = clickedNode['title-html'];
                        }
                    } else {
                        document.getElementById('tooltip-window').value     = '';
                        document.getElementById('tooltip-window').innerHTML = '';
                    }
                });
                
                network.on('afterDrawing', () => {
                });

                function updateCenterOnZoom(network, scale) {
                    var canvas = network.canvas.frame.canvas;
                    var container = network.getContainer();

                    var containerRect = container.getBoundingClientRect();
                    var x = containerRect.width / 2;
                    var y = containerRect.height / 2;

                    var canvasCenter = network.DOMtoCanvas({ x: x, y: y });

                    var deltaX = (canvas.width / 2 - canvasCenter.x) * (scale - 1);
                    var deltaY = (canvas.height / 2 - canvasCenter.y) * (scale - 1);

                    network.moveTo({
                        position: { x: network.getViewPosition().x - deltaX, y: network.getViewPosition().y - deltaY },
                        scale: scale
                    });
                }

                network.on("zoom",function(params){
                    //updateCenterOnZoom(network, params.scale);
                    //return;
                    let scale = network.getScale()
                    if(verbose)
                        console.log(`zoom handler: scale=${scale} MIN_ZOOM=${MIN_ZOOM} MAX_ZOOM=${MAX_ZOOM} lastZoomPosition=${lastZoomPosition}`)
                    if(scale <= MIN_ZOOM )
                    {
                        network.moveTo({
                            position: lastZoomPosition,
                            scale: MIN_ZOOM
                        });
                    }
                    else if(scale >= MAX_ZOOM ){
                        network.moveTo({
                            position: lastZoomPosition,
                            scale: MAX_ZOOM,
                        });
                    }

                    lastZoomPosition = network.getViewPosition()

                });

                function doOnHoverNode(e) {
                    if (timeoutId) {
                        clearTimeout(timeoutId);
                    }
                    timeoutId = setTimeout(function() {
                        const tooltipElement = document.getElementsByClassName('vis-tooltip');
                        if(tooltipElement!=null) {
                            try {
                                tooltipElement[0].style.visibility='hidden';
                            }
                            catch(err) {
                                console.log(`Caught exception '${err.message}' while processing "tooltipElement[0].style.visibility='hidden'"`)
                            }
                        }
                    }, 4000);
                }

                network.on("dragEnd",function(params){
                    lastZoomPosition = network.getViewPosition()
                    console.log(`dragEnd handler: MIN_ZOOM=${MIN_ZOOM} MAX_ZOOM=${MAX_ZOOM} lastZoomPosition=${lastZoomPosition}`)
                });
                
                network.on('hoverNode', function (e) {
                    //doOnHoverNode(e)
                });

                const canvasElement = document.getElementById('mynetwork');
                if(canvasElement!=null) {
                    //canvasElement.setAttribute('tabindex','0');
                    /// canvasElement.focus();
                    //console.log('canvasElement OK');
                    //canvasElement.dispatchEvent(new MouseEvent('mousedown', { bubbles: true, cancelable: true }));
                    //canvasElement.dispatchEvent(new MouseEvent('mouseup', { bubbles: true, cancelable: true }));
                    //// canvasElement.dispatchEvent(new KeyboardEvent('keydown', { keyCode: 13 }));
                    //network.keyboard.enabled = true;
                }

                function debounce(func, delay) {
                    let timeoutId;
                    return function() {
                        const context = this;
                        const args = arguments;
                        clearTimeout(timeoutId);
                        timeoutId = setTimeout(() => {
                            func.apply(context, args);
                        }, delay);
                    };
                }

                function getCurrentNodeID() {
                    let svalue=document.getElementById('select-need-id');
                    if(svalue.options.length>0) {
                        text = svalue.options[svalue.selectedIndex].text;
                        return getID(text);
                    }
                    return null;
                }

                function getOtherNetworkLayout() {
                    return {
                        autoResize: false,
                        locale: 'en',
                        interaction:getInteractionData(),
                        nodes: {
                            borderWidth:2,
                            borderWidthSelected:4,
                            color: {
                                border:"black"
                            },
                            // size : 15,
                            //font: { align: 'center', valign: 'middle' }
                            font: {'face': 'monospace', 'align': 'center',size: 40, color: "Black"},
                            fixed: {
                                    'x': false,
                                    'y': false,
                            },
                            heightConstraint: {
                                minimum: 50
                                //maximum: 50
                            },
                            widthConstraint: {
                                minimum: 150,
                                maximum: 200
                            }
                        },
                        edges: {
                            arrows: { to: {enabled: true} },
                            width: 0.01,
                            hoverWidth: 5.0,
                            "color": {
                                "inherit": false
                            },
                            "smooth": {
                                "enabled": false,
                                "type": "horizontal"
                            }
                        },
                        physics: {
                            enabled: true,
                            "hierarchicalRepulsion": {
                                "centralGravity": 0,
                                "nodeDistance": 305
                            },
                            "stabilization": {
                                "enabled": true, // Enable stabilization
                                "iterations": 500, // Number of stabilization iterations
                                "fit": false // Fit the network after stabilization
                            },
                            "minVelocity": 0.75,
                            "solver": "hierarchicalRepulsion"
                        },
                        configure: {
                            enabled: false,
                            showButton: false,
                            filter: ['layout','physics']
                        },
                        layout: {
                            randomSeed: 1,
                            "hierarchical":false
                        }
                    };
                }

                function afterDrawingEventHandler() {
                    //console.log('afterDrawingEventHandler()');
                    network.fit({maxZoomLevel:0.4});
                    //network.off("afterDrawing",afterDrawingEventHandler);
                }

                function stabilizationIterationsDoneEventHandler() {
                    //console.log('stabilizationIterationsDoneEventHandler()');
                    network.fit({maxZoomLevel:0.4});
                    //network.off("stabilizationIterationsDone",stabilizationIterationsDoneEventHandler);
                }

                function changeLayout(setLayout=true) {
                    network.setOptions(getOtherNetworkLayout());
                    if(!setLayout) {
                        network.on("afterDrawing",afterDrawingEventHandler);
                        network.on("stabilizationIterationsDone",stabilizationIterationsDoneEventHandler);
                        setTimeout(function() {
                            network.off("afterDrawing",afterDrawingEventHandler);
                            network.off("stabilizationIterationsDone",stabilizationIterationsDoneEventHandler);
                            network.fit({maxZoomLevel:0.4});
                        },2000);
                    }
                }

                function handleKeyUp(event) {
                    // console.log(event.target.value);
                    if(processingInputFilter)
                        return

                    const charPressed = String.fromCharCode(event.keyCode);
                    suggestionsList.innerHTML = "";
                    $('#input').removeClass('input-active').addClass('input-inactive');

                    ecounter+=1;

                    if(charPressed==='v'||charPressed==='V') {
                        event.preventDefault();
                        console.log("ENTER pressed");
                        let svalue=document.getElementById('select-need-id');
                        if(svalue.options.length>0) {
                            text = svalue.options[svalue.selectedIndex].text;
                            viewMode=(viewMode+1)%3;
                            drawFilteredGraph(getID(text));
                            //console.log(`viewMode update -> ${viewMode}`);
                        }
                    }
                    // jump to node list beginning
                    if(charPressed==='b'||charPressed==='B')
                        handleSelectFirstNodeEvent();

                    // jump to node list end
                    if(charPressed==='e'||charPressed==='E')
                        handleSelectLastNodeEvent();

                    // previous node
                    if(charPressed==='p'||charPressed==='P') {
                        event.preventDefault();
                        console.log(`prev Key Up ${ecounter}`);
                        handleSelectPrevNodeEvent();
                    }

                    // next node
                    if(charPressed==='n'||charPressed==='N') {
                        event.preventDefault();
                        console.log(`next Key Up ${ecounter}`);
                        handleSelectNextNodeEvent();
                    }

                    // toggle network layout direction
                    if(charPressed==='l'||charPressed==='L') {
                        //event.preventDefault();
                        console.log("I'm here!");

                        if(layoutDirection==='') {
                            layoutDirection='DU';
                            network.setOptions( getDefaultNetworkLayout() );
                            network.fit({maxZoomLevel:0.4});
                        }
                        else
                        if(layoutDirection==='DU') {
                            layoutDirection='RL';
                            network.setOptions( getDefaultNetworkLayout('RL') );
                            network.fit({maxZoomLevel:0.4});
                        }
                        else {
                            layoutDirection='';
                            changeLayout(true);
                            setTimeout(function() {
                                 changeLayout(false);
                            },100);
                        }
                        return
                    }

                    // copy current network as JSON to clipboard
                    if(event.ctrlKey && (charPressed==='c'||charPressed==='C')) {
                        copyNetworkToClipboard();
                    }

                    // copy current network as SVG to clipboard
                    if(event.ctrlKey && (charPressed==='s'||charPressed==='S')) {
                        copyNetworkAsSVGToClipboard();
                        return;
                    }

                    if(charPressed==='s'||charPressed==='S') {
                        var serializedString=document.URL;
                        const params = {
                            type:   $("#select-type").val(),
                            filter: $('#select-filter').val(),
                            id:     $('#select-need-id').val(),
                            layout: layoutDirection
                        };
                        const queryString = new URLSearchParams(params).toString();
                        serializedString+=`?${queryString}`;

                        const urlSearchParams=new URLSearchParams(queryString);
                        const decodedData = Object.fromEntries(urlSearchParams.entries());
                        console.log(decodedData);
                        //}
                        
                        document.getElementById('tooltip-window').innerHTML = serializedString;

                        navigator.clipboard.writeText(serializedString)
                        .then(function() {
                            console.log('URL+params copied to clipboard successfully!');
                        })
                        .catch(function(error) {
                            console.error('Unable to copy URL+params to clipboard: ', error);
                        });
                    }
                }
                networkContainer = document.getElementById('mynetwork');
                //networkContainer.addEventListener('keyup',debounce(handleKeyUp,300));
                networkContainer.addEventListener('keyup',handleKeyUp);
                window.addEventListener('resize', handleResize);
            }

            function copyNetworkAsSVGToClipboard() {
                return
            }

            function copyNetworkToClipboard() {
                var serializedData = {
                    nodes: network.body.data.nodes.get({ returnType: "Object" }),
                    edges: network.body.data.edges.get({ returnType: "Object" })
                };
                // Step 2: Convert serialized data to a string
                var serializedString = JSON.stringify(serializedData);
                // Step 3: Copy the string to clipboard
                navigator.clipboard.writeText(serializedString)
                    .then(function() {
                        console.log('Network data copied to clipboard successfully!');
                    })
                    .catch(function(error) {
                        console.error('Unable to copy network data to clipboard: ', error);
                    });
            }

            function identifyCyclicReferences(network) {
                const visitedNodes = {}; // Set to track visited nodes
                const cyclicReferences = []; // Array to store cyclic references

                // Traverse the network using DFS
                function dfs(node) {
                    visitedNodes[node.id] = true; // Mark node as visited

                    for (const connectedNode of node.links) {
                    if (visitedNodes[connectedNode.id]) {
                        // Detect cyclic reference
                        cyclicReferences.push([node.id, connectedNode.id]);
                        return true; // Stop traversing
                    } else if (dfs(connectedNode)) {
                        return true; // Stop traversing if a cyclic reference is detected
                    }
                    }

                    return false; // No cyclic reference found
                }

                // Perform DFS for all nodes
                for (const node of network.nodes) {
                    if (!visitedNodes[node.id] && dfs(node)) {
                    break; // Stop after detecting the first cyclic reference
                    }
                }
                return cyclicReferences;
            }

            function createLoopNode(cyclicReference) {
                const loopNode = {
                    id: 'loop_' + new Date().getTime(), // Generate a unique ID for the loop node
                    label: 'Cyclic Loop', // Set a descriptive label
                    nodes: cyclicReference, // Store the nodes involved in the loop
                    incoming: [], // Create empty connections arrays
                    outgoing: [],
                };
                return loopNode;
            }

            function updateNodeConnections(cyclicReference, loopNode) {
                // Extract nodes involved in the loop
                const [node1, node2] = cyclicReference;

                // Update connections for node 1
                node1.incoming.forEach((connection) => {
                    if (connection.to.id === node2.id) {
                    connection.to = loopNode;
                    }
                });

                node1.outgoing.forEach((connection) => {
                    if (connection.from.id === node2.id) {
                    connection.from = loopNode;
                    }
                });

                // Update connections for node 2
                node2.incoming.forEach((connection) => {
                    if (connection.to.id === node1.id) {
                    connection.to = loopNode;
                    }
                });

                node2.outgoing.forEach((connection) => {
                    if (connection.from.id === node1.id) {
                    connection.from = loopNode;
                    }
                });
            }

            function copyCyclicNetworkToClipboard(network) {
                // Identify and handle cyclic references
                const cyclicReferences = identifyCyclicReferences(network);
                for (const cyclicReference of cyclicReferences) {
                    // Represent the loop as a single node
                    const loopNode = createLoopNode(cyclicReference);
                    network.addNode(loopNode);

                    // Update node connections to connect to the loop node
                    updateNodeConnections(cyclicReference, loopNode);
                }
                // Convert network data to clipboard format
                const networkData = convertNetworkDataToClipboardFormat(network);
                // Set clipboard content
                setClipboardContent(networkData);
            }

            // function copyNetworkToClipboard(network) {
            //     document.addEventListener('copy', (event) => {
            //         const networkData = JSON.stringify(network); // Convert network data to JSON
            //         event.clipboardData.setData('text/plain', networkData); // Set clipboard content
            //         alert('Network copied to clipboard successfully!'); // Notify user
            //     });
            // }

            function drawCurrentSelection(pnode) {
                var pnodeId=pnode.id
                const expanded=!pnode.expanded;
                const visited = [];
                var stack = [];
                stack=[pnodeId];
                var clickedNode = nodes.get(pnodeId);
                
                nodes.update({id:pnodeId,expanded:expanded,
                    shape:expanded?'box':'big ellipse'});
                while(stack.length) {
                    const currentNode = stack.pop();
                    if(visited.includes(currentNode))
                        continue;
                    visited.push(currentNode);
                    if(currentNode!=pnodeId) {
                        nodes.update({id:currentNode,hidden:!expanded});
                        if(nodes.get(currentNode).expanded) {
                            for(const node of children[currentNode])
                                stack.push(gnodes[node].id);
                        }
                    } else {
                        for(const node of children[currentNode]) {
                            //if(viewMode || !viewMode && parents[node].length==1)
                            if(viewMode==0)
                                stack.push(gnodes[node].id);
                        }
                    }
                }
                network.fit({maxZoomLevel:0.4});
            }

            function incType(typeFrequency,type) {
                if(!(type in typeFrequency))
                    typeFrequency[type]=0
                typeFrequency[type]+=1;
            }

            function drawFilteredGraph(rootNodeLabel) {
                const visited = [];
                var stack = [];
                if(rootNodeLabel in gnodes)
                    stack=[gnodes[rootNodeLabel]];
                tmp_nodes=[];
                let tmp_edges=[];
                var numChildren=-1;
                var numParents=-1;
                var typeFrequency={};
                if(rootNodeLabel!=="") {
                    if(viewMode===0) {
                        while(stack.length) {
                            const currentNode = stack.pop();
                            if(visited.includes(currentNode.label))
                                continue;
                            if(currentNode.label!=rootNodeLabel)
                                incType(typeFrequency,gnodes[currentNode.label]['data']['type'])
                            numChildren+=1;
                            visited.push(currentNode.label);
                            var clonedObject = { ...currentNode, ...{'hidden':false,'expanded':true} };
                            tmp_nodes.push(clonedObject);
                            for(const node of children[currentNode.label]) {
                                stack.push(gnodes[node]);
                                // if(!viewMode) {
                                //     for(const n of parents[node])
                                //         stack.push(gnodes[n]);
                                // }
                            }
                            tmp_edges=tmp_edges.concat(children_edges[currentNode.label]);
                        }
                    }
                    if(viewMode===1) {
                        while(stack.length) {
                            const currentNode = stack.pop();
                            if(visited.includes(currentNode.label))
                                continue;
                            if(currentNode.label!=rootNodeLabel)
                                incType(typeFrequency,gnodes[currentNode.label]['data']['type'])
                            numParents+=1;
                            visited.push(currentNode.label);
                            var clonedObject = { ...currentNode, ...{'hidden':false,'expanded':true} };
                            tmp_nodes.push(clonedObject);
                            for(const node of parents[currentNode.label])
                                stack.push(gnodes[node]);
                            tmp_edges=tmp_edges.concat(parents_edges[currentNode.label]);
                        }
                    }
                    if(viewMode===2) {
                        while(stack.length) {
                            const currentNode = stack.pop();
                            if(visited.includes(currentNode.label))
                                continue;
                            if(currentNode.label!=rootNodeLabel)
                                incType(typeFrequency,gnodes[currentNode.label]['data']['type'])
                            numChildren+=1;
                            visited.push(currentNode.label);
                            var clonedObject = { ...currentNode, ...{'hidden':false,'expanded':true} };
                            tmp_nodes.push(clonedObject);
                            for(const node of children[currentNode.label]) {
                                stack.push(gnodes[node]);
                                // if(!viewMode) {
                                //     for(const n of parents[node])
                                //         stack.push(gnodes[n]);
                                // }
                            }
                            tmp_edges=tmp_edges.concat(children_edges[currentNode.label]);
                        }

                        for(const node of parents[rootNodeLabel])
                            stack.push(gnodes[node]);
                        tmp_edges=tmp_edges.concat(parents_edges[rootNodeLabel]);
                        numParents=0;
                        while(stack.length) {
                            const currentNode = stack.pop();
                            if(visited.includes(currentNode.label))
                                continue;
                            if(currentNode.label!=rootNodeLabel)
                                incType(typeFrequency,gnodes[currentNode.label]['data']['type'])
                            numParents+=1;
                            visited.push(currentNode.label);
                            var clonedObject = { ...currentNode, ...{'hidden':false,'expanded':true} };
                            tmp_nodes.push(clonedObject);
                            for(const node of parents[currentNode.label])
                                stack.push(gnodes[node]);
                            tmp_edges=tmp_edges.concat(parents_edges[currentNode.label]);
                        }
                    }
                }
                if(verbose) {
                    console.log("nodes");
                    console.log(tmp_nodes);
                    console.log("edges");
                    console.log(tmp_edges);
                }                
                nodes = new vis.DataSet(tmp_nodes);
                edges = new vis.DataSet(tmp_edges);

                network.setData({ nodes: nodes, edges: edges });

                if(rootNodeLabel!=="") {
                    var msg;
                    if(viewMode==0)
                        msg=`=== In-Neighbours View\n\nNumber of incoming neighbours=${numChildren}`
                    else if(viewMode==1)
                        msg=`=== Out-Neighbours View\n\nNumber of outgoing neighbours=${numParents}`
                    else
                        msg=`=== InOut-Neighbours View\n\nNumber of incoming neighbours=${numChildren}\nNumber of outgoing neighbours=${numParents}`
                    if(Object.keys(typeFrequency).length>0)
                        msg+="\n\n"
                    for(const type in  typeFrequency)
                        msg+=`.. '${type}'=${typeFrequency[type]}\n`
                    if(Object.keys(typeFrequency).length>0)
                        msg+="\n"
                    else
                        msg+="\n\n"
                    
                    nodes.update({
                        id:rootNodeLabel,
                        title:`${msg}${gnodes[rootNodeLabel]['title']}`,
                        borderWidth:2,
                        heightConstraint: {
                                minimum: 200
                        },
                        widthConstraint: {
                            minimum: 300,
                            maximum: 300
                        },
                        color: {
                            border:'red'
                        }
                    });
                }
                
                if(layoutDirection==='')
                    network.once("stabilized", function() {
                        network.fit({ maxZoomLevel: 0.4 });
                    });
                    /*setTimeout(function() {
                        network.fit({maxZoomLevel:0.4});
                        lastZoomPosition = network.getViewPosition();
                    },500);*/
                else {
                    network.fit({maxZoomLevel:0.4});
                    lastZoomPosition = network.getViewPosition();
                }
            }
            
            $(document).ready(function() {
                $('#select-type').select2({
                    dropdownCssClass :'typedrop'
                });                
                $('#select-need-id2').select2();
                $("#select-need-id").select2({
                    //width: '100%' // need to override the changed default
                    dropdownCssClass : 'bigdrop',
                });
                initSelectFilter();
            });

            const textBox = document.getElementById('input');

            $("#input").focus(function(){
                processingInputFilter=true;
                textBox.style.width = '100%';
                textBox.style.zIndex = 10;
                textBoxEditingActive=true;
                $('#mynetwork').css('opacity','0.5');
                /*$('#mynetwork').css({
                    'border': '5px solid red',
                    'padding': '10px'
                });*/
                //$('#input').attr("class","input-active");
                $('#input').removeClass('input-inactive').addClass('input-active');

                console.log(`$("#input").focus(function())`)
            });

            $("#input").blur(function() {
                processingInputFilter=false;
                $('#mynetwork').css('opacity','1.0');
                //$('#mynetwork').css('border','none');
                $('#mynetwork').focus();
                //network.setOptions( saveOpt );
                return;
                var textBox = $(this);
                var text=$(this).val().trim(); // Get the text content and remove leading/trailing whitespaces
                handleSelectTypeEvent();
                console.log(`$("#input").blur(function())`);
                //$(this).off('keydown',handleKeydown);
                if(network!=null) {
                    network.setOptions( saveOpt );
                }
                const canvasElement = document.getElementById('mynetwork');
                if(canvasElement!=null) {
                    //canvasElement.setAttribute('tabindex','0');
                    //canvasElement.focus();
                }
            });

            function findOptionByText(select2Element,text) {
                return option = select2Element.find('option').filter(function() {
                        const curText=$(this).text().trim();
                        return curText === text.trim();
                    });
            }
            function printOption(option) {
                if (option.length > 0) {
                    console.log(`option.value=${option.val()}`);
                    console.log(`option.text=${option.text()}`);
                    console.log(`option.info=${option.data('info')}`);
                } else {
                    console.log(`The option is invalid and cannot be printed`);
                }
            }
            function handleKeydown(e) {
                //console.log('handleKeydown()');
                //e.preventDefault();
                if (e.key === 'Escape') {
                    suggestionsList.innerHTML = "";
                    //$('#input').addClass("input-inactive").removeClass("input-active");
                    //$('#input').attr("class","input-inactive");
                    $('#input').removeClass('input-active').addClass('input-inactive');
                    if(canvasElement!=null)
                        canvasElement.onclick();
                } else
                if (e.key === 'Enter') {
                    suggestionsList.innerHTML = "";
                    var newText = $('#input').val().trim();
                    var selectedValue = $('#select-filter').val();
                    var selectedOption = $('#select-filter').select2('data')[0];
                    //printOption(selectedOption);
                    const option = findOptionByText($("#select-filter"),"Select");
                    //printOption(option);
                    newOption=findOptionByText($("#select-filter"),newText);
                    if (newOption.length > 0) {
                        //console.log("Option with text '" + newText + "' already exists.");
                        setCurrentSelectionByText(newText);
                    } else {
                        console.log("Option with text '" + newText + "' does not exist.");
                        if(newOption.length>0) {
                            //$('#select-filter option[value=`selectedValue`]').text(newText);
                            setCurrentSelectionByText(newText);
                            $('#select-filter option').filter(function () {
                                 return $(this).text() === 'Select';
                            }).remove();
                            $('#select-filter').trigger('change.select2');
                        } else {
                            userInput=newText;
                            task();
                        }
                        handleSelectTypeEvent();
                    }
                    initSelectFilter();
                    //$('#input').attr("class","input-inactive");
                    $('#input').removeClass('input-active').addClass('input-inactive');
                }  else {
                    const phrase = $('#input').val();
                    const suggestions = [];

                    const currentWord = phrase.split(new RegExp(`[${autocompletionDelimiters.join("\\")}]`)).pop();
                    const regex = new RegExp("^" + currentWord, "i");
                    for (const word of autocompletionAttributes) {
                        if (regex.test(word)) {
                            suggestions.push(word);
                            console.log(`suggestion=${word}`)
                        }
                    }
                    suggestionsList.innerHTML = "";
                    for (const suggestion of suggestions) {
                        const listItem = document.createElement("li");
                        listItem.textContent = suggestion;
                        listItem.addEventListener("click", function () {
                            console.log(`currentWord=${currentWord}`);
                            console.log(`phrase=${phrase.replace(/\\/g,"")}`);
                            const regex = new RegExp(`${currentWord}$`);
                            //input.value = phrase.replace(regex,"").replace(/\\/g,"") + suggestion;
                            var inputField = $('#input');
                            inputField.val(phrase.replace(regex,"").replace(/\\/g,"") + suggestion);
                        });
                        suggestionsList.appendChild(listItem);
                    }
                }
            }

            $('#input').on('keydown',handleKeydown);

            window.onclick = function(event) {
                const modal = document.getElementById('helpModal');
                if (event.target === modal) {
                    modal.style.display = 'none';
                }
            }

            function textExists(text) {
                var exists = false;
                $('#select-filter option').each(function () {
                    if ($(this).text().trim() === text.trim()) {
                    exists = true;
                    return false;
                    }
                });
                return exists;
            }

            function initSelectFilter() {
                $('#select-filter').select2({
                    dropdownCssClass: 'bigdropFilter',
                    allowClear: true,
                    placeholder: 'Filters',
                    language: {
                    noResults: function () {
                        return `<button style="width: 100%" type="button"
                            class="btn btn-primary" 
                            onClick='task()'>+ Add New Item</button>
                            </li>`;
                    }
                    },
                    escapeMarkup: function (markup) {
                    return markup;
                    }
                });

                $('#select-filter').on('select2:open', function () {
                    $('.select2-search__field').on('input', function () {
                    userInput = $(this).val();
                    });
                });

                // Event listener to handle removal of options
                $('#select-filter').on('select2:unselecting', function (e) {
                    var removedOption = $(e.params.args.data.element);
                    removedOption.remove(); // Remove the option from the dropdown
                });

                $('#select-filter').on('select2:select', function (e) {
                    const selectedOption = e.params.data;
                    const selectedValue = selectedOption.id; // Access option ID if needed
                    const selectedText = selectedOption.text;
                    var inputField = $('#input');
                    inputField.val(selectedText);
                    handleSelectTypeEvent();
                });
                if(filters!=null) {
                    for(item of filters) {
                        $('#select-filter').append($('<option>', {
                            value: item,
                            text: item
                        }));
                    }
                    $('#select-filter').trigger('change.select2')
                    filters=null;
                }
            }

            function setCurrentSelectionByText(text) {
                $('#select-filter option').each(function () {
                    if ($(this).text().trim() === text.trim()) {
                        $('#select-filter').val($(this).val()).trigger('change.select2');
                        return false;
                    }
                });
            }

            function task(updateInput=true) {
                console.log(userInput);
                if (userInput) {
                    $('#select-filter').append($('<option>', {
                    value: userInput,
                    text: userInput
                    })).trigger('change.select2');
                    $('#select-filter').val(userInput).trigger('change.select2');
                    if(updateInput) {
                        var inputField = $('#input');
                        inputField.val(userInput);
                        initSelectFilter();
                        handleSelectTypeEvent();
                    }
                }
            }
        </script>
    </body>
</html>
