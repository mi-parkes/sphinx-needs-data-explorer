<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Sphinx_Needs Data Explorer</title>
        <script src="vis-network/vis-network.min.js"
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="jquery/jquery-3.7.1.min" 
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <link href="select2/select2.min.css" rel="stylesheet" />
        <script src="select2/select2.min.js" 
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="peg/peg-0.10.0.min.js"
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <link href="sphinx_needs_data_explorer.css" rel="stylesheet"/>
        <script src="sphinx_needs_data_explorer.js"
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>

        <link rel="stylesheet" type="text/css" href="sphinx-needs/libs/html/datatables.min.css" />
        <link rel="stylesheet" type="text/css" href="sphinx-needs/common.css" />
        <link rel="stylesheet" type="text/css" href="sphinx-needs/styles.css" />
        <link rel="stylesheet" type="text/css" href="sphinx-needs/modern.css" />
        <link rel="stylesheet" type="text/css" href="sphinx-needs/layouts.css" />

        <script src="sphinx-needs/libs/html/datatables.min.js"
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="sphinx-needs/libs/html/datatables_loader.js"
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="sphinx-needs/libs/html/sphinx_needs_collapse.js"
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>

        <center>
            <h1></h1>
        </center>
            <center>
            <h1></h1>
        </center>
    </head>
    <body>
        <div id="helpModal" class="modal">
            <div class="modal-content">
            <span class="close" onclick="closeHelpDialog()">&#88;</span>
                <h2>About this Software</h2>
                <table class="ack-table">
                    <thead>
                        <tr>
                            <th class="ack-th">Name</th>
                            <th class="ack-th">Version</th>
                            <th class="ack-th">License</th>
                            <th class="ack-th">Github</th>
                            <th class="ack-th">PyPi</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td class="ack-td"><b>sphinx_needs_data_explorer</b></td>
                            <td class="ack-td">{{VERSION}}</td>
                            <td class="ack-td"><a href="https://raw.githubusercontent.com/mi-parkes/sphinx-needs-data-explorer/main/LICENSE"><b>MIT</b></a></td>
                            <td class="ack-td"><a href="https://github.com/mi-parkes/sphinx-needs-data-explorer">sphinx-needs-data-explorer</a></td>
                            <td class="ack-td"><a href="https://pypi.org/project/sphinx-needs-data-explorer/">sphinx-needs-data-explorer</a></td>
                        </tr>
                    </tbody>
                </table>
                <br>
                <hr>
                <h2>Acknowledgments</h2>
                This Software utilizes the following copyrighted material, the use of which is hereby acknowledged.<br>                
                <br>
                <table class="ack-table">
                    <thead>
                        <tr>
                            <th class="ack-th">Name</th>
                            <th class="ack-th">Version</th>
                            <th class="ack-th">License</th>
                            <th class="ack-th">Github</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td class="ack-td"><b>sphinx-needs</b></td>
                            <td class="ack-td">2.0.0</td>
                            <td class="ack-td"><a href="https://github.com/useblocks/sphinx-needs/blob/master/LICENSE"><b>MIT</b></a></td>
                            <td class="ack-td"><a href="https://github.com/useblocks/sphinx-needs">https://github.com/useblocks/sphinx-needs</a></td>
                        </tr>
                        <tr>
                            <td class="ack-td"><b>pegjs</b></td>
                            <td class="ack-td">0.10.0</td>
                            <td class="ack-td"><a href="https://github.com/pegjs/pegjs/blob/master/LICENSE"><b>MIT</b></a></td>
                            <td class="ack-td"><a href="https://github.com/pegjs/pegjs">https://github.com/pegjs/pegjs</a></td>
                        </tr>
                        <tr>
                            <td class="ack-td"><b>vis-network</b></td>
                            <td class="ack-td">9.1.9</td>
                            <td class="ack-td"><a href="https://github.com/visjs/vis-network/blob/master/LICENSE-MIT"><b>MIT</b></a></td>
                            <td class="ack-td"><a href="https://github.com/visjs/vis-network">https://github.com/visjs/vis-network</a></td>
                        </tr>
                        <tr>
                            <td class="ack-td"><b>select2</b></td>
                            <td class="ack-td">4.1.0-rc.0</td>
                            <td class="ack-td"><a href="https://github.com/select2/select2/blob/develop/LICENSE.md"><b>MIT</b></a></td>
                            <td class="ack-td"><a href="https://github.com/select2/select2">https://github.com/select2/select2</a></td>
                        </tr>
                        <tr>
                            <td class="ack-td"><b>jQuery</b></td>
                            <td class="ack-td">3.7.1</td>
                            <td class="ack-td"><a href="https://github.com/jquery/jquery/blob/main/LICENSE.txt"><b>MIT</b></a></td>
                            <td class="ack-td"><a href="https://github.com/jquery/jquery">https://github.com/jquery/jquery</a></td>
                        </tr>
                        <tr>
                            <td class="ack-td"><b>DataTables</b></td>
                            <td class="ack-td">1.10.16</td>
                            <td class="ack-td"><a href="https://raw.githubusercontent.com/DataTables/DataTablesSrc/master/license.txt"><b>MIT</b></a></td>
                            <td class="ack-td"><a href="https://github.com/DataTables/DataTablesSrc">https://github.com/DataTables/DataTablesSrc</a></td>
                        </tr>
                    </tbody>
                </table>
                <br>
                <hr>
                <!-- https://codepen.io/gschier/pen/VKgyaY -->
            <h2>Help Information</h2>
                <h3>Keyboard shortcuts</h3>
                <table>
                    <tbody>
                        <tr>
                            <td class="kbd-td"><kbd>F1</kbd></td>
                            <td>Help</td>
                        </tr>
                        <tr>
                            <td colspan="2">&nbsp;</td>
                        </tr>
                        <tr>
                            <td class="kbd-td"><kbd>&uarr;</kbd></td>
                            <td>Move network up</td>
                        </tr>
                        <tr>
                            <td class="kbd-td"><kbd>&darr;</kbd></td>
                            <td>Move network down</td>
                        </tr>
                        <tr>
                            <td class="kbd-td"><kbd>&larr;</kbd></td>
                            <td>Move network left</td>
                        </tr>
                        <tr>
                            <td class="kbd-td"><kbd>&rarr;</kbd></td>
                            <td>Move network right</td>
                        </tr>
                        <tr>
                            <td class="kbd-td"><kbd>R</kbd></td>
                            <td>Reset network display (position and scale)</td>
                        </tr>
                        <tr>
                            <td colspan="2">&nbsp;</td>
                        </tr>
                        <tr>
                            <td class="kbd-td"><kbd>P</kbd></td>
                            <td>Navigate to the previous sphinx_need item</td>
                        </tr>
                        <tr>
                            <td class="kbd-td"><kbd>N</kbd></td>
                            <td>Navigate to the next sphinx_need item</td>
                        </tr>
                        <tr>
                            <td class="kbd-td"><kbd>L</kbd></td>
                            <td>Cycle network layout mode</td>
                        </tr>
                        <tr>
                            <td class="kbd-td"><kbd>V</kbd></td>
                            <td>Cycle network neighbour view mode</td>
                        </tr>

                        <tr>
                            <td class="kbd-td"><kbd>&lt;</kbd></td>
                            <td>Decrease neighborhood depth view of the current node</td>
                        </tr>
                        <tr>
                            <td class="kbd-td"><kbd>&gt;</kbd></td>
                            <td>Increase neighborhood depth view of the current node</td>
                        </tr>
                        <tr>
                            <td class="kbd-td"><kbd>B</kbd></td>
                            <td>Beginning of sphinx_need item list</td>
                        </tr>
                        <tr>
                            <td class="kbd-td"><kbd>E</kbd></td>
                            <td>End of sphinx_need item list</td>
                        </tr>
                        <tr>
                            <td class="kbd-td"><kbd>ESC</kbd></td>
                            <td >Hide the tooltip associated with the currently hovered-over node</td>
                        </tr>
                        <tr>
                            <td class="kbd-td"><kbd>S</kbd></td>
                            <td>store the current URL, including search parameters, to the clipboard for the purpose of restoring their browsing context later</td>
                        </tr>

                    </tbody>
                </table>
                <br>
                <h3>Mouse events</h3>
                <ul>
                    <li>Hovering over a node displays tooltip with basic node information</li>
                    <li>Alt+click at node shows detailed node information in popup window, including a link where complete information 
                        can be found</li>
                </ul>
                <br>
                <h3>Data Filtering Examples</h3>
                Note: the explorer uses a simplified Python syntax for expressing data filtering criteria.
                <br>
                <br>
                <table class="ack-table">
                    <tbody>
                        <tr>
                            <td class="att-td">'S_\' in id</td>
                            <td>Find items that contains 'S_' in its id</td>
                        </tr>
                        <tr>
                            <td class="att-td">'arch' in docname</td>
                            <td>Find items defined in specific file that<br>contains keyword 'arch' (case sensitive)</td>
                        </tr>
                        <tr>
                            <td class="att-td">'architecture/architecture-needs'==docname</td>
                            <td>Find items defined in specific file</td>
                        </tr>
                        <tr>
                            <td class="att-td">status in ['open','closed']</td>
                            <td>Find open or closed items</td>
                        </tr>
                        <tr>
                            <td class="att-td">(status=='open' && (type in ['req'])) || ('arch' in docname)</td>
                            <td>A complex expression that incorporates techniques from the previous examples.</td>
                        </tr>
                        <tr>
                            <td class="att-td">tags!=[] && title ~ /techn/i #case insensitive match</td>
                            <td>RegEx case insensitive match</td>
                        </tr>
                        <tr>
                            <td class="att-td">title ~ /^Level[ \t]+(?=one)/</td>
                            <td>RegEx positive lookaheads</td>
                        </tr>
                        <tr>
                            <td class="att-td">title ~ /^Level[ \t]+(?!one)/</td>
                            <td>RegEx negative lookaheads</td>
                        </tr>
                        <tr>
                            <td class="att-td">type=='test' && outgoing==[]</td>
                            <td>Find test which are not linked yet</td>
                        </tr>
                        <tr>
                            <td class="att-td">type != 'test' && incoming==[]</td>
                            <td>Find items with no incoming links</td>
                        </tr>
                    </tbody>
                </table>
                <br>
                <h3>Sphinx-Needs attributes found in this project that can be used for data filtering:</h3>
                <table class="ack-table">
                    <thead>
                      <tr>
                        <th class="ack-th">Name</th>
                        <th class="ack-th">Type</th>
                      </tr>
                    </thead>
                    <tbody id="help-attributes">
                    </tbody>
                </table>
            </div>
        </div>
        <div>
            <div class="row">
                <div id="display-needs-count" title="This number shows how many sphinx-needs items match the active filter(s). NDV stands for Neighborhood Depth View">
                    Filter matches: 0 IDs
                </div>
                <select title="selectType" id="select-type" onchange="handleSelectTypeEvent()" 
                    class="select2 select2-container select2-container--bootstrap select2-container--focus"
                    title="Select which Sphinx-Needs type you want view">
                </select>
                <input type="text" id="input"
                    title="Here you can specify filter expression. See Help for examples." 
                    class="input-inactive">
                <select title="selectFilter" id="select-filter" 
                    title="You can select from already defined or define new or delete existing filter"
                    class="select2 select2-container select2-container--bootstrap select2-container--focus"
                    >
                    <option value="">Select</option>
                </select>
                <select title="selectNode" id="select-need-id" onchange="handleSelectNodeEvent()" class="select2 select2-container select2-container--bootstrap select2-container--focus">
                    <option value="">Select Sphinx-Needs 'ID'...</option>
                </select>
                <button id="explorerModeButton" onclick="exploreMode()" 
                    title="View Perpsective [Network, Table, File]">Network</button>
                <button id="helpButton" onclick="openHelpDialog()" 
                    title="View how to use Sphinx-Needs-Data-Explorer">Help
                </button>
            </div>
            <ul id="suggestions"></ul>
            <div id="tooltip-window" class="tooltip-window"></div>
            <div id="mynetwork" tabindex="0">
            </div>
        </div>
        <script type="text/javascript">
            const extra_options = {{ EXTRA_OPTIONS }};
            var inUpdateTable=0;
            var filters = {{FILTERS}};
            const link_types = {{ LINK_TYPES }};
            var networkContainer;
            const autocompletionDelimiters = [" ",",", "[", "("];
            var suggestionsList;
            var autocompletionAttributes;
            var processingInputFilter=false;
            var userInput;
            var startTime;
            var ecounter=0;
            let verbose=false;
            let MIN_ZOOM = 0.1;
            let MAX_ZOOM = 2.0;
            var viewMode=0;
            var viewModeMaxDepth=3;
            var textBoxEditingActive=false;
            var lastTextBoxValue="";
            var saveOpt;
            var tmp_nodes;
            var networkData;
            let lastZoomPosition = {x:0, y:0}
            var selectedType;
            var needs;
            var nodes;
            var network=null;
            var container;
            var options, data;
            var filterWasUsed=false;
            var timeoutId = null;
            var gnodes={};
            var children;
            var children_edges;
            var parents;
            var parents_edges;
            var layoutDirection='DU';
            var 
            needsURL = "../needs.json";
            var parser;
            let grammar;
            const traceParser=false;
            var mode=0;

            // <table class="NEEDS_DATATABLES colwidths-given rtd-exclude-wy-table no-sphinx-material-strip table" id="needtable-requirements-0-table_node">
            //const tableTemplate=`<table id="example" tabindex="0" style="width:100%'"></table>`;
            
            const dataTableTemplate=`
                <table class="NEEDS_DATATABLES 
                    colwidths-given rtd-exclude-wy-table no-sphinx-material-strip table" 
                    id="needtable"
                    tabindex="0" style="width:100%'">
                </table>
            `;

            var absolute = function(rel) { 
                var link = document.createElement("a"); 
                link.href = rel; 
                return (link.protocol + "//" + link.host + link.pathname); 
            }                 

            function expandArrays(a) {
                let o = '';
                for (e of a)
                    o += e.constructor === Array ? expandArrays(e) : e;
                return o;
            }

            function customFilter(key,currentNode,expr) {
                return Node.create(expr).evaluate(currentNode);
            }
            function isValidUrl(string) {
                try {
                    new URL(string);
                    return true;
                } catch (err) {
                    return false;
                }
            }

            function setCurrentTypeSelectionByText(text) {
                $('#select-type option').each(function () {
                    if ($(this).text().trim() === text.trim()) {
                        $('#select-type').val($(this).val()).trigger('change.select2');
                        return false;
                    }
                });
            }

            var urlToFetch=isValidUrl(needsURL)?url=needsURL:absolute(needsURL);

            const queryString = window.location.search;
            const urlSearchParams = new URLSearchParams(queryString);
            const decodedData = Object.fromEntries(urlSearchParams.entries());

            console.log('decodedData -->');
            console.log(decodedData);

            console.log(urlToFetch);
            let fetchRes = fetch(urlToFetch);
            fetchRes.then(res =>  
                res.json()).then(data => {
                    console.log(`project=${data['project']}`);
                    processJSON(data);
                    prepareParser();
                    suggestionsList = document.getElementById("suggestions");

                    if('type' in decodedData && decodedData['type']!=null) {
                        if('layout' in decodedData)
                            layoutDirection=decodedData['layout']
                        if('view' in decodedData && decodedData['view'])
                            viewMode=parseInt(decodedData['view']);
                    }

                    initNetwork();
                    handleSelectTypeEvent();
                    if('type' in decodedData && decodedData['type']!=null) {
                        if('filter' in decodedData && decodedData['filter']!=null) {
                            const newText=decodedData['filter']
                            $('#input').val(decodedData['filter']).trigger('change.select2');
                            newOption=findOptionByText($("#select-filter"),newText);
                            if (newOption.length > 0) {
                                //console.log("Option with text '" + newText + "' already exists.");
                                setCurrentSelectionByText(newText);
                            }
                        }
                        setCurrentTypeSelectionByText(decodedData['type']);
                        if('id' in decodedData && decodedData['id']!=null )
                            $('#select-need-id').val(decodedData['id']).trigger('change.select2');
                    }
                    $('.vis-network').focus();
                    $('.vis-network').trigger($.Event('keydown', { key: 'Enter' }));
                }
            ).catch(error => {
                console.log(`Failed featching needs data:${urlToFetch} -> ${error}`);
            });

            type2color= {{TYPE2COLOR}};

            function handleResize() {
                //console.log('HandlingResize');
                if(network!=null) {
                    network.redraw();
                    network.fit({maxZoomLevel:0.4});
                }
            }

            function parse_links(need) {
                links = [];
                for(const link_type of link_types) {
                    if(link_type in need)
                        links=links.concat(need[link_type]);
                }
                return links;
            }

            function compareByTwoKeys(a,b) {
                const diff1=gnodes[b]['data']['depth']-gnodes[a]['data']['depth'];
                if(diff1!==0)
                    return diff1;
                return gnodes[b]['data']['sum']-gnodes[a]['data']['sum'];
            }

            var visited = [];
            var stack = [];

            function computeDepth(key) {
                let depth=0;
                visited.push(key);
                for(const cur of children[key]) {
                    if(cur in needs) {
                        if(!visited.includes(cur))
                            computeDepth(cur);
                        let curDepth=gnodes[cur]['data']['depth']+1;
                        if(depth<curDepth)
                            depth=curDepth;
                    }
                }
                gnodes[key]['data']['depth']=depth;
            }
            
            // Compute max depth from each root node - BEG
            function computeNodeDepth() {
                visited = [];
                stack = [];
                for(let key in gnodes) {
                    if(visited.includes(key))
                        continue;
                    computeDepth(key);
                }
            }

            function _computeNodeSumOfSubnodes(key) {
                let sum=0;
                visited.push(key);
                for(const cur of children[key]) {
                    if(cur in needs) {
                        if(!visited.includes(cur))
                        _computeNodeSumOfSubnodes(cur);
                        sum+=gnodes[cur]['data']['sum']+1;
                    }
                }
                gnodes[key]['data']['sum']=sum;
            }

            // Compute node's sub-nodes sum
            function computeNodeSumOfSubnodes() {
                visited = [];
                stack = [];
                for(let key in gnodes) {
                    if(visited.includes(key))
                        continue;
                    _computeNodeSumOfSubnodes(key);
                }
            }

            function processJSON(data) {
                var vkey="";
                Object.keys(data['versions']).forEach(function(key) {
                    vkey=key;
                })
                if(vkey.length==0) {
                    console.log("Failed to find data");
                    return;
                }
                needs=data['versions'][vkey]['needs']
                let nodes=[];
                children={};
                children_edges={};
                parents={};
                parents_edges={};
                gnodes={};
                let typeSet = new Set(['any']);

                for(const key in needs) {
                    if(verbose)
                        console.log(key,needs[key].docname);
                    children[key]=[];
                    children_edges[key]=[];
                    parents[key]=[];
                    parents_edges[key]=[];
                    typeSet.add(needs[key]['type']);
                    var jsonData={'data':{
                        "type"  :       needs[key]['type'],
                        "title" :       needs[key]['title'],
                        "status":       needs[key]['status'],
                        "docname":      needs[key]['docname'],
                        "tags":         needs[key]['tags'],
                        "lineno":       'lineno' in needs[key]?needs[key]['lineno']:1,
                        //"description":  convert_text_to_html(needs[key]['description']),
                        "description":  needs[key]['description'],
                        "description":  needs[key]['description'],
                        'id':           needs[key]['id'],
                        "depth" :0,
                        "count" :0,
                        "sum":0
                    }};

                    for(const option of extra_options) {
                        if(option in needs[key])
                            jsonData['data'][option]=needs[key][option]
                    }

                    for(const link_type of link_types) {
                        if(link_type in needs[key])
                            jsonData['data'][link_type]=needs[key][link_type]
                    }

                    jsonData["shape"]='box'
                    jsonData["id"]=needs[key].id
                    jsonData["label"]=needs[key].id
                    //jsonData["size"]= { width: 30, height: 30 } }
                    jsonData["title"]=`id=${needs[key]['id']}\ntype=${needs[key]['type']}\nstatus=${needs[key]['status']}\ntitle=${needs[key]['title']}`
                    jsonData["title-html"]=`<b>type</b>=${needs[key]['type']}<br>`
                    jsonData["title-html"]=`
                    <table class="ack-table">
                        <thead>
                        <tr>
                            <th class="at-td">id</th>
                            <th class="at-td">type</th>
                            <th class="at-td">status</th>
                            <th class="at-td">title</th>
                            <th class="at-td">docname</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td class="at-td" title="${jsonData["id"]}">${jsonData["id"]}</td>
                            <td class="at-td" title="${jsonData["data"]["type"]}">${jsonData["data"]["type"]}</td>
                            <td class="at-td" title="${jsonData["data"]["status"]}">${jsonData["data"]["status"]}</td>
                            <td class="at-td" title="${jsonData["data"]["title"]}">${jsonData["data"]["title"]}</td>
                            <td class="at-td">
                                <a href="../${jsonData["data"]["docname"]}.html#${jsonData["id"]}"
                                title="${jsonData["data"]["docname"]}.html}">${jsonData["data"]["docname"]}.html#${jsonData["id"]}</a>
                            </td>
                        </tr>
                    </tbody>
                    </table>
                    `
                    //
                    if(needs[key].type in type2color) {
                        jsonData["color"]=type2color[needs[key].type];
                    } else {
                        jsonData["color"]='white'
                    }
                    gnodes[key]=jsonData
                }

                if(Object.keys(gnodes).length>0) {
                    const firstKey = Object.keys(gnodes)[0];
                    autocompletionAttributes=[];
                    for(const att of Object.keys(gnodes[firstKey]['data']).sort()){
                        var type=typeof gnodes[firstKey]['data'][att];
                        if(type==='object')
                            type=Array.isArray(gnodes[firstKey]['data'][att])?'array':'object';
                        if(!['depth','sum','count'].includes(att))  {
                            //$("#help-attributes").append(`<li>'${att}':${typeof gnodes[firstKey]['data'][att]}</li>`);
                            $("#help-attributes").append(`<tr>
                            <td class="att-td">${att}</td>
                            <td class="att-td">${type}</td>
                            </tr>`.replace(/^[\s]+/gm,""))
                            autocompletionAttributes.push(`${att} (${type})`);
                        }
                    }
                    // synthetic attributes
                    att='outgoing'
                    $("#help-attributes").append(`<tr>
                            <td class="att-td">${att}</td>
                            <td class="att-td">${typeof parents[firstKey]}</td>
                            </tr>`.replace(/^[\s]+/gm,""))
                    autocompletionAttributes.push(`${att} (array)`);
                    att='incoming'
                    $("#help-attributes").append(`<tr>
                            <td class="att-td">${att}</td>
                            <td class="att-td">${typeof children[firstKey]}</td>
                            </tr>`.replace(/^[\s]+/gm,""))
                    autocompletionAttributes.push(`${att} (array)`);
                }

                for(const key in needs) {
                    for(to of parse_links(needs[key])) {
                        if(to in needs) {
                            if(verbose)
                                console.log(to);
                            var jsonData={"arrows":"to","from":key,"to":to};
                            children[to].push(key);
                            children_edges[to].push(jsonData);
                            parents[key].push(to);
                            parents_edges[key].push(jsonData);
                        }
                    }
                }
                let stype=document.getElementById('select-type')
                for(elm of typeSet) {
                    var opt = document.createElement('option');
                        opt.value = elm;
                        opt.innerHTML = elm;
                        stype.appendChild(opt);
                }
                //for(elm of documents)
                //    console.log(elm);
                computeNodeDepth();
                computeNodeSumOfSubnodes();
                return;
            }

            function getID(text) {
                const nonSpaceRegex = /\b\S+\b/;
                const firstNonSpaceWord = text.match(nonSpaceRegex);
                if (firstNonSpaceWord)
                    return firstNonSpaceWord[0];
                return "";
            }

            function handleSelectFirstNodeEvent() {
                let svalue=document.getElementById('select-need-id');
                if(svalue.options.length>0 && svalue.selectedIndex!=0) {
                    var $select = $('#select-need-id');
                    $select.prop('selectedIndex',0).trigger('change');
                    var text = $('#select-need-id option:selected').text();
                    console.log('handleSelectNextNodeEvent',svalue.selectedIndex,svalue.options.length,text);
                    drawFilteredGraph(getID(text));
                }
            }

            function handleSelectLastNodeEvent() {
                let svalue=document.getElementById('select-need-id');
                if(svalue.options.length>0 && svalue.selectedIndex!=(svalue.options.length-1)) {
                    var $select = $('#select-need-id');
                    $select.prop('selectedIndex',svalue.options.length-1).trigger('change');
                    var text = $('#select-need-id option:selected').text();
                    console.log('handleSelectNextNodeEvent',svalue.selectedIndex,svalue.options.length,text);
                    drawFilteredGraph(getID(text));
                }
            }

            function handleSelectPrevNodeEvent() {
                let svalue=document.getElementById('select-need-id');
                if(svalue.options.length>0 && svalue.selectedIndex>0) {
                    var $select = $('#select-need-id');
                    $select.prop('selectedIndex', svalue.selectedIndex - 1).trigger('change');
                    var text = $('#select-need-id option:selected').text();
                    console.log('handleSelectNextNodeEvent',svalue.selectedIndex,svalue.options.length,text);
                    drawFilteredGraph(getID(text));
                }
            }

            function handleSelectNextNodeEvent() {
                let svalue=document.getElementById('select-need-id');
                if(svalue.options.length>0 && (svalue.selectedIndex+1)<svalue.options.length) {
                    var $select = $('#select-need-id');
                    $select.prop('selectedIndex', svalue.selectedIndex + 1).trigger('change');
                    var text = $('#select-need-id option:selected').text();
                    console.log('handleSelectNextNodeEvent',svalue.selectedIndex,svalue.options.length,text);
                    drawFilteredGraph(getID(text));
                }
            }

            function handleSelectNodeEvent() {
                let svalue=document.getElementById('select-need-id');
                var text="";
                if(svalue.options.length>0)
                     text = svalue.options[svalue.selectedIndex].text;
                drawFilteredGraph(getID(text));
            }

            function removeNewlinesAndTrimString(str) {
                return str.trim().replace(/\n/g,'');
            }

            function handleSelectTypeEvent() {
                clearFilter();
                let stype=document.getElementById('select-type');
                let type = stype.options[stype.selectedIndex].value;
                let svalue=document.getElementById('select-need-id');
                let tmp_nodes=[]
                var customFilterExpression=null;
                const textBox = document.getElementById('input');
                const userInputText=removeNewlinesAndTrimString(textBox.value);
                if(userInputText.length>0) {
                    if(parser!=null) {
                        customFilterExpression=parse_input(parser,gnodes,userInputText);
                        if(customFilterExpression==null)
                            $('#input').css('color','red');
                        else
                            $('#input').css('color','white');
                    }
                }
                if(userInputText.length==0 || userInputText.length>0 && customFilterExpression!=null) {
                    try {
                        for (let each in gnodes) {
                            if(type==='any' || gnodes[each]['data']['type']===type) {
                                if( (customFilterExpression===null) || 
                                    (customFilterExpression!==null && 
                                    custom_filter(each,gnodes[each],customFilterExpression)
                                    )) {
                                    tmp_nodes.push(each);
                                }
                            }
                        }
                    } catch (error) {
                        console.log(`Failure executing eval('${customFilterExpression}') ${error}`);
                    }
                }
                if(tmp_nodes.length>0) {
                    console.log('tmp_nodes');
                    console.log(tmp_nodes[0]);
                    tmp_nodes.sort(compareByTwoKeys);
                } else {
                    console.log('tmp_nodes empty!');
                }
                if(mode==1)
                    setTimeout(function() {
                        updateTable1(tmp_nodes);
                            },1);
                else
                if(mode==2)
                    updateTable2(tmp_nodes);

                for (let each of tmp_nodes) {
                    var opt = document.createElement('option');
                    opt.text   = `${each} - ${gnodes[each]["data"]["title"]}`;
                    svalue.appendChild(opt);
                }
                // Change Select List Option Background-Color on Hover in CSS
                // for(option of svalue.options) {
                //     option.style.background = 'color:"red"';
                // }
                //document.getElementById('display-needs-count').innerHTML = `Found '${+counter.toString()}' instances of type ->`;
                /// document.getElementById('display-needs-count').innerHTML = `Filter matches '${+counter.toString()}' IDs`;
                document.getElementById('display-needs-count').innerHTML = `Filter matches ${tmp_nodes.length} IDs, NDV:${viewModeMaxDepth}`;
                handleSelectNodeEvent();
            }

            let selectType = function() {
                return function () {
                    let selectedType = arguments[0];
                    handleSelectTypeEvent(selectedType);
                    console.log(selectedProperty)
                }
            }

            function openHelpDialog() {
                if(network!=null)
                    network.setOptions({ interaction: { keyboard: false } });
                document.getElementById('helpModal').style.display = 'block';
            }

            // Close the help dialog
            function closeHelpDialog() {
                document.getElementById('helpModal').style.display = 'none';
                network.setOptions({ interaction: { keyboard: true } });
            }

            function transformAndJoin(data,gnodes) {
                const transformedData = [];
                for (const key of data) {
                    const docname = gnodes[key]['data']?.["docname"];
                    if (docname) {
                        const transformedValue = `
                            <a href="../${docname}.html#${key}"
                            title="${docname}.html">${key}</a>`;
                        transformedData.push(transformedValue);
                    } else {
                        //transformedData.push("");
                    }
                }
                return transformedData;
            }

            function updateTable1(tmp_nodes) {
                if(inUpdateTable>0) {
                    console.log('inUpdateTable>0!!!');
                    return;
                }
                inUpdateTable+=1;
                if(tmp_nodes!=null && tmp_nodes.length>0) {
                    console.log(`updateTable1 tmp_nodes.length=${tmp_nodes.length}`);
                    var data=[];
                    for(const elm of tmp_nodes) {
                        data.push({...gnodes[elm]['data']});
                        const id=data[data.length-1]['id'];
                        data[data.length-1]['id']=`<a href="../${gnodes[elm]['data']['docname']}.html#${id}"
                        title="${gnodes[elm]['data']['docname']}.html">${id}</a>`
                        data[data.length-1]['outgoing']=parents[id];
                        data[data.length-1]['incoming']=children[id];
                    }

                    var mcolumns=[]
                    const defaultColumns=['id','title','status','type'];
                    if(Object.keys(data[0]).length>0) {
                        for(const key of defaultColumns)
                            mcolumns.push({ title:key, data:key, visible: true })
                        for(const link_type of link_types.concat(['outgoing','incoming'])) {
                            if(link_type in data[0])
                                mcolumns.push({ title:link_type, data:link_type, visible: false,
                                    render: function ( data, type, row ) {
                                        return (data)?transformAndJoin(data,gnodes).join(', '):'';
                                    }
                                })
                        }
                        for(const key in data[0]) {
                            if(typeof data[0][key] === 'string' && !defaultColumns.includes(key))
                                mcolumns.push({ title:key, data:key, visible: false })
                        }
                        for(const key in data[0]) {
                            var type=typeof data[0][key];
                            if(type==='object')
                                type=Array.isArray(data[0][key])?'array':'object';
                            if(type === 'array') {
                                if(!link_types.concat(['outgoing','incoming']).includes(key))
                                    mcolumns.push({ title:key, data:key, visible: false,
                                        render: function ( data, type, row ) {
                                            return (data)?data.join(', '):'';
                                        }
                                    })
                            }
                        }
                    }
                    $('#needtable').DataTable().destroy();
                    $(`#mynetwork #needtable`).remove();

                    var table = $(dataTableTemplate);
                    table.appendTo('#mynetwork');
                    table = $('#needtable').DataTable({
                        dom: 'lBfrtip',
                        lengthChange: true,
                        lengthMenu: [
                            [10, 15, 50, -1],
                            ["10", "15", "50", "All"]
                        ],
                        pageLength: 15,
                        // scrollY: "300px",
                        scrollCollapse: true,
                        buttons: [
                            'colvis',
                            'copy',
                            'csv',
                            'excel',
                            'pdf',
                            'print'
                        ],
                        stateSave: true,
                        searching: false,
                        data: data,
                        columns: mcolumns,
                        select: 'single'
                    });
                    $('.dataTable').focus();
                    $('#needtable tbody').on('click', 'tr', function () {
                        if ($(this).hasClass('selected')) {
                            $(this).removeClass('selected');
                        } else {
                            table.$('tr.selected').removeClass('selected');
                            $(this).addClass('selected');
                        }
                    });
                } else {
                    if ($('#needtable').length>0) {
                        $('#needtable').DataTable().destroy();
                        $('#mynetwork #needtable').remove();
                    }
                }
                inUpdateTable-=1;
            }

            function updateTable2(tmp_nodes) {
                if(tmp_nodes!=null && tmp_nodes.length>0) {
                    var data=[];
                    let documentSet = new Set([]);
                    tmp_nodes.forEach(elm => {documentSet.add(gnodes[elm]['data']['docname'])});
                    for(elm of documentSet)
                        data.push({'docname':`<a href="../${elm}.html" title="${elm}.html}">${elm}</a>`});
                    var mcolumns=[]
                    const defaultColumns=['docname'];
                    if(tmp_nodes.length>0 && Object.keys(data[0]).length>0) {
                        for(const key of defaultColumns) {
                            mcolumns.push({ title:key, data:key, visible: true })
                        }
                    }
                    $('#needtable').DataTable().destroy();
                    $('#mynetwork #needtable').remove();
                    var table = $(dataTableTemplate);
                    table.appendTo('#mynetwork');
                    table = $('#needtable').DataTable({
                        dom: 'lBfrtip',
                        lengthChange: true,
                        lengthMenu: [
                            [ 10, 15, 50, -1 ],
                            [ "10", "20", "50", "All"]
                        ],
                        // scrollY: "300px",
                        scrollCollapse: true,
                        buttons: [
                            'colvis',
                            'copy',
                            'csv',
                            'excel',
                            'pdf',
                            'print'
                        ],
                        stateSave: true,
                        searching: true,
                        data: data,
                        columns: mcolumns,
                        select: 'single'
                    });
                    $('.dataTable').focus();
                    $('#needtable tbody').on('click', 'tr', function () {
                        if ($(this).hasClass('selected')) {
                            $(this).removeClass('selected');
                        } else {
                            table.$('tr.selected').removeClass('selected');
                            $(this).addClass('selected');
                        }
                    });
                } else {
                    if ($('#needtable').length>0) {
                        $('#needtable').DataTable().destroy();
                        $('#mynetwork #needtable').remove();
                    }
                }
            }

            function exploreMode() {
                //setTimeout(function() {
                    mode=(mode+1)%3;
                    if(mode==0) {
                        $('#select-need-id').prop('disabled',false);
                        $('#needtable').DataTable().destroy();
                        $('#mynetwork #needtable').remove();
                        $("#explorerModeButton").text("Network");
                        initNetwork();
                        handleSelectTypeEvent();
                        $('.vis-network').focus();
                        $('.vis-network').trigger($.Event('keydown', { key: 'Enter' }));
                    }
                    else
                    if(mode==1) {
                        $('#select-need-id').prop('disabled',true);
                        $("#explorerModeButton").text("Table");
                        network.destroy();
                        network=null;
                        handleSelectTypeEvent();
                    }
                    else
                    if(mode==2) {
                        $("#explorerModeButton").text("File");
                        handleSelectTypeEvent();
                    }
                //},1);
            }

            function clearFilter() {
                $('#select-need-id').val('');
                $('#select-need-id').empty();
            }

            function getInteractionData() {
                return { 
                            hover: true,
                            tooltipDelay:200,
                            navigationButtons: false,
                            selectable:true,
                            zoomView:true,
                            dragView:true,
                            keyboard:{
                                enabled:false
                                // enabled:!textBoxEditingActive
                            }
                        };
            }

            function getDefaultNetworkLayout(layoutDirection='DU') {
                return {
                    autoResize: false,
                    locale: 'en',
                    interaction:getInteractionData(),
                    nodes: {
                        borderWidth:2,
                        borderWidthSelected:4,
                        color: {
                            border:"black"
                        },
                        // size : 15,
                        //font: { align: 'center', valign: 'middle' }
                        font: {'face': 'monospace', 'align': 'center',size: 40, color: "Black"},
                        fixed: {
                                'x': false,
                                'y': true,
                        },
                        heightConstraint: {
                            minimum: 50
                            //maximum: 50
                        },
                        widthConstraint: {
                            minimum: 150,
                            maximum: 200
                        }
                    },
                    edges: {
                        arrows: { to: {enabled: true} },
                        width: 0.01,
                        hoverWidth: 5.0,
                        "color": {
                            "inherit": false
                        },
                        "smooth": {
                            "enabled": false,
                            "type": "horizontal"
                        }
                    },
                    physics: {
                        enabled: false,
                    },
                    configure: {
                        enabled: false,
                        showButton: false,
                        filter: ['layout','physics']
                    },
                    layout: {
                        randomSeed: 1,
                        improvedLayout: false,
                        hierarchical: {
                            enabled: true,
                            sortMethod: 'directed',  // hubsize, directed
                            shakeTowards: 'leaves',  // roots, leaves
                            direction: layoutDirection,   // UD, DU, LR, RL
                            levelSeparation: 350,
                            nodeSpacing: 350,
                            // treeSpacing: 200,
                            blockShifting: false,
                            edgeMinimization: false,
                            parentCentralization: true
                        }
                    }
                };
            }
            function initNetwork() {
                var container = document.getElementById('mynetwork');
                nodes = new vis.DataSet([]);
                edges = new vis.DataSet([]);
                // adding nodes and edges to the graph
                data = {nodes: nodes, edges: edges};

                if(layoutDirection!=="")
                    network = new vis.Network(container, data, getDefaultNetworkLayout(layoutDirection));
                else
                    network = new vis.Network(container, data, getOtherNetworkLayout());

                saveOpt = { 
                    interaction: JSON.parse( JSON.stringify( network.interactionHandler.options ) ) 
                };

                networkData=network.body.data;
                network.on('select', function(selection){
                    let selectedNodeIds = selection.nodes; // array of selected node's ids
                    let selectedNodes = nodes.get(selectedNodeIds); // retrive node objects from dataSet object
                    //document.getElementById('tooltip-window').innerHTML = selectedNodes[0]['title-html'];
                });

                network.on('deselectNode', function (properties) {
                    //document.getElementById('tooltip-window').innerHTML = '';
                });

                network.on("doubleClick", function (properties) {
                    var ids = properties.nodes;
                    if(ids.length==0) {
                        return
                    }
                    var clickedNodes = nodes.get(ids);
                    var pnode=clickedNodes[0]
                    drawCurrentSelection(pnode);
                    return;
                });

                function closeInput() {
                    if($('#input').css('color')==='rgb(255,0,0)')
                        $('#input').css('color','black');
                    $('#input').removeClass('input-active').addClass('input-inactive');
                    if(textBoxEditingActive) {
                        textBoxEditingActive=false;
                        network.setOptions({ interaction: { keyboard: true } });
                    }
                }

                network.on('click', function (properties) {
                    suggestionsList.innerHTML = "";
                    closeInput();
                    var oEvent = properties.event.srcEvent;
                    if(properties.nodes.length>0) {
                        if(oEvent.shiftKey) {
                            var ids = properties.nodes;
                            if(ids.length==0) {
                                return
                            }
                            var clickedNodes = nodes.get(ids);
                            var pnode=clickedNodes[0]
                            drawCurrentSelection(pnode);
                            return;
                        }
                        if(oEvent.altKey) {
                            var id = properties.nodes[0];
                            var clickedNode = nodes.get(id);
                            //document.getElementById('tooltip-window').value     = clickedNode['title'];
                            document.getElementById('tooltip-window').innerHTML = clickedNode['title-html'];
                        }
                    } else {
                        document.getElementById('tooltip-window').value     = '';
                        document.getElementById('tooltip-window').innerHTML = '';
                    }
                });

                network.on('afterDrawing', () => {
                });

                function updateCenterOnZoom(network, scale) {
                    var canvas = network.canvas.frame.canvas;
                    var container = network.getContainer();

                    var containerRect = container.getBoundingClientRect();
                    var x = containerRect.width / 2;
                    var y = containerRect.height / 2;

                    var canvasCenter = network.DOMtoCanvas({ x: x, y: y });

                    var deltaX = (canvas.width / 2 - canvasCenter.x) * (scale - 1);
                    var deltaY = (canvas.height / 2 - canvasCenter.y) * (scale - 1);

                    network.moveTo({
                        position: { x: network.getViewPosition().x - deltaX, y: network.getViewPosition().y - deltaY },
                        scale: scale
                    });
                }

                network.on("zoom",function(params){
                    //updateCenterOnZoom(network, params.scale);
                    //return;
                    let scale = network.getScale()
                    if(verbose)
                        console.log(`zoom handler: scale=${scale} MIN_ZOOM=${MIN_ZOOM} MAX_ZOOM=${MAX_ZOOM} lastZoomPosition=${lastZoomPosition}`)
                    if(scale <= MIN_ZOOM )
                    {
                        network.moveTo({
                            position: lastZoomPosition,
                            scale: MIN_ZOOM
                        });
                    }
                    else if(scale >= MAX_ZOOM ){
                        network.moveTo({
                            position: lastZoomPosition,
                            scale: MAX_ZOOM,
                        });
                    }

                    lastZoomPosition = network.getViewPosition()

                });

                network.on("dragEnd",function(params){
                    lastZoomPosition = network.getViewPosition()
                    console.log(`dragEnd handler: MIN_ZOOM=${MIN_ZOOM} MAX_ZOOM=${MAX_ZOOM} lastZoomPosition=${lastZoomPosition}`)
                });

                function handleHoverNode(e) {
                    return;
                    if (timeoutId) {
                        clearTimeout(timeoutId);
                    }
                    timeoutId = setTimeout(function() {
                        const tooltipElement = document.getElementsByClassName('vis-tooltip');
                        if(tooltipElement!=null) {
                            try {
                                tooltipElement[0].style.visibility='hidden';
                            }
                            catch(err) {
                                console.log(`Caught exception '${err.message}' while processing "tooltipElement[0].style.visibility='hidden'"`)
                            }
                        }
                    },4000);
                }

                function handleBlurNode(event) {
                    $('.vis-tooltip').css('display','block');
                }
                network.on('hoverNode',handleHoverNode);
                network.on('blurNode',handleBlurNode);

                function debounce(func, delay) {
                    let timeoutId;
                    return function() {
                        const context = this;
                        const args = arguments;
                        clearTimeout(timeoutId);
                        timeoutId = setTimeout(() => {
                            func.apply(context, args);
                        }, delay);
                    };
                }

                function getCurrentNodeID() {
                    let svalue=document.getElementById('select-need-id');
                    if(svalue.options.length>0) {
                        text = svalue.options[svalue.selectedIndex].text;
                        return getID(text);
                    }
                    return null;
                }

                function getOtherNetworkLayout() {
                    return {
                        autoResize: false,
                        locale: 'en',
                        interaction:getInteractionData(),
                        nodes: {
                            borderWidth:2,
                            borderWidthSelected:4,
                            color: {
                                border:"black"
                            },
                            // size : 15,
                            //font: { align: 'center', valign: 'middle' }
                            font: {'face': 'monospace', 'align': 'center',size: 40, color: "Black"},
                            fixed: {
                                    'x': false,
                                    'y': false,
                            },
                            heightConstraint: {
                                minimum: 50
                                //maximum: 50
                            },
                            widthConstraint: {
                                minimum: 150,
                                maximum: 200
                            }
                        },
                        edges: {
                            arrows: { to: {enabled: true} },
                            width: 0.01,
                            hoverWidth: 5.0,
                            "color": {
                                "inherit": false
                            },
                            "smooth": {
                                "enabled": false,
                                "type": "horizontal"
                            }
                        },
                        physics: {
                            enabled: true,
                            "hierarchicalRepulsion": {
                                "centralGravity": 0,
                                "nodeDistance": 305
                            },
                            "stabilization": {
                                "enabled": true, // Enable stabilization
                                "iterations": 500, // Number of stabilization iterations
                                "fit": false // Fit the network after stabilization
                            },
                            "minVelocity": 0.75,
                            "solver": "hierarchicalRepulsion"
                        },
                        configure: {
                            enabled: false,
                            showButton: false,
                            filter: ['layout','physics']
                        },
                        layout: {
                            randomSeed: 1,
                            "hierarchical":false
                        }
                    };
                }

                function afterDrawingEventHandler() {
                    //console.log('afterDrawingEventHandler()');
                    network.fit({maxZoomLevel:0.4});
                    //network.off("afterDrawing",afterDrawingEventHandler);
                }

                function stabilizationIterationsDoneEventHandler() {
                    //console.log('stabilizationIterationsDoneEventHandler()');
                    network.fit({maxZoomLevel:0.4});
                    //network.off("stabilizationIterationsDone",stabilizationIterationsDoneEventHandler);
                }

                function changeLayout(setLayout=true) {
                    network.setOptions(getOtherNetworkLayout());
                    if(!setLayout) {
                        network.on("afterDrawing",afterDrawingEventHandler);
                        network.on("stabilizationIterationsDone",stabilizationIterationsDoneEventHandler);
                        setTimeout(function() {
                            network.off("afterDrawing",afterDrawingEventHandler);
                            network.off("stabilizationIterationsDone",stabilizationIterationsDoneEventHandler);
                            network.fit({maxZoomLevel:0.4});
                        },2000);
                    }
                }

                function handleKeyUp(event) {
                    if(processingInputFilter)
                        return
                    suggestionsList.innerHTML = "";
                    $('#input').removeClass('input-active').addClass('input-inactive');
                    ecounter+=1;
                    if (event.key === 'Escape' || event.keyCode === 27) {
                        $('.vis-tooltip').css('display', 'none');
                        return;
                    }
                    if (event.key === '>' && event.shiftKey) {
                        event.preventDefault();
                        if(viewModeMaxDepth<10 && network!==null) {
                            viewModeMaxDepth+=1;
                            //let svalue=document.getElementById('select-need-id');
                            //if(svalue.options.length>0 && svalue.selectedIndex!=0) {
                            document.getElementById('display-needs-count').innerHTML = `Filter matches ${$('#select-need-id').children('option').length} IDs, NDV:${viewModeMaxDepth}`;
                            handleSelectNodeEvent();
                        }
                    } else
                    if (event.key === '<' && event.shiftKey) {
                        event.preventDefault();
                        if(viewModeMaxDepth>0 && network!==null) {
                            viewModeMaxDepth-=1;
                            document.getElementById('display-needs-count').innerHTML = `Filter matches ${$('#select-need-id').children('option').length} IDs, NDV:${viewModeMaxDepth}`;
                            handleSelectNodeEvent();
                        }
                    } else
                    if (event.key === 'ArrowLeft' && network!==null) {
                        event.preventDefault();
                        console.log("ArrowLeft");
                        const currentPosition = network.getViewPosition();
                        const offset = {x:(event.shiftKey)?100:50, y: 0};
                        const newPosition = {x: currentPosition.x + offset.x, y: currentPosition.y + offset.y};
                        network.moveTo({position: newPosition});
                        return;
                    } else if (event.key === 'ArrowRight' && network!==null) {
                        event.preventDefault();
                        console.log("ArrowRight");
                        const currentPosition = network.getViewPosition();
                        const offset = {x:(event.shiftKey)?100:50, y: 0};
                        const newPosition = {x: currentPosition.x - offset.x, y: currentPosition.y + offset.y};
                        network.moveTo({position: newPosition});
                        return;
                    } else if (event.key === 'ArrowUp' && network!==null) {
                        event.preventDefault();
                        console.log("ArrowUp");
                        //setTimeout(function() {
                        const currentPosition = network.getViewPosition();
                        const offset = {x:0, y:(event.shiftKey)?100:50}; // Adjust x and y for desired movement (pixels)
                        const newPosition = {x: currentPosition.x + offset.x, y: currentPosition.y + offset.y};
                        network.moveTo({position: newPosition});
                        //},2000);
                        return;
                    } else if (event.key === 'ArrowDown' && network!==null) {
                        event.preventDefault();
                        console.log("ArrowDown");
                        const currentPosition = network.getViewPosition();
                        const offset = {x:0,y:(event.shiftKey)?100:50}; // Adjust x and y for desired movement (pixels)
                        const newPosition = {x: currentPosition.x + offset.x, y: currentPosition.y - offset.y};
                        network.moveTo({position: newPosition});
                        return;
                    }
                    // reset network display
                    if(event.key==='r'||event.key==='R') {
                        event.preventDefault();
                        if(network!=null)
                            network.fit({maxZoomLevel:0.4});
                        return;
                    }
                    if(event.key==='v'||event.key==='V') {
                        event.preventDefault();
                        let svalue=document.getElementById('select-need-id');
                        if(svalue.options.length>0) {
                            text = svalue.options[svalue.selectedIndex].text;
                            viewMode=(viewMode+1)%3;
                            drawFilteredGraph(getID(text));
                            //console.log(`viewMode update -> ${viewMode}`);
                        }
                    }
                    // jump to node list beginning
                    if(event.key==='b'||event.key==='B')
                        handleSelectFirstNodeEvent();

                    // jump to node list end
                    if(event.key==='e'||event.key==='E')
                        handleSelectLastNodeEvent();

                    // previous node
                    if(event.key==='p'||event.key==='P') {
                        event.preventDefault();
                        console.log(`prev Key Up ${ecounter}`);
                        handleSelectPrevNodeEvent();
                        return;
                    }

                    // next node
                    if(event.key==='n'||event.key==='N') {
                        event.preventDefault();
                        console.log(`next Key Up ${ecounter}`);
                        handleSelectNextNodeEvent();
                        return;
                    }

                    // toggle network layout direction
                    if(event.key==='l'||event.key==='L') {
                        event.preventDefault();
                        if(network!=null) {
                            if(layoutDirection==='') {
                                layoutDirection='DU';
                                network.setOptions( getDefaultNetworkLayout() );
                                network.fit({maxZoomLevel:0.4});
                            }
                            else
                            if(layoutDirection==='DU') {
                                layoutDirection='RL';
                                network.setOptions( getDefaultNetworkLayout('RL') );
                                network.fit({maxZoomLevel:0.4});
                            }
                            else {
                                layoutDirection='';
                                changeLayout(true);
                                setTimeout(function() {
                                    changeLayout(false);
                                },100);
                            }
                        }
                        return
                    }

                    // copy current network as JSON to clipboard
                    if(event.ctrlKey && (event.key==='c'||event.key==='C')) {
                        copyNetworkToClipboard();
                    }

                    // copy current network as SVG to clipboard
                    if(event.ctrlKey && (event.key==='s'||event.key==='S')) {
                        copyNetworkAsSVGToClipboard();
                        return;
                    }

                    if(event.key==='s'||event.key==='S') {
                        var serializedString=document.URL;
                        const params = {
                            type:   $("#select-type").val(),
                            filter: $('#select-filter').val(),
                            id:     $('#select-need-id').val(),
                            layout: layoutDirection,
                            view: viewMode
                        };
                        const queryString = new URLSearchParams(params).toString();
                        serializedString+=`?${queryString}`;

                        const urlSearchParams=new URLSearchParams(queryString);
                        const decodedData = Object.fromEntries(urlSearchParams.entries());
                        console.log(decodedData);

                        document.getElementById('tooltip-window').innerHTML = serializedString;

                        navigator.clipboard.writeText(serializedString)
                        .then(function() {
                            console.log('URL+params copied to clipboard successfully!');
                        })
                        .catch(function(error) {
                            console.error('Unable to copy URL+params to clipboard: ', error);
                        });
                    }
                }
                networkContainer = document.getElementById('mynetwork');
                //networkContainer.addEventListener('keyup',debounce(handleKeyUp,300));
                networkContainer.addEventListener('keyup',handleKeyUp);
            }

            function copyNetworkAsSVGToClipboard() {
                return
            }

            function copyNetworkToClipboard() {
                var serializedData = {
                    nodes: network.body.data.nodes.get({ returnType: "Object" }),
                    edges: network.body.data.edges.get({ returnType: "Object" })
                };
                // Step 2: Convert serialized data to a string
                var serializedString = JSON.stringify(serializedData);
                // Step 3: Copy the string to clipboard
                navigator.clipboard.writeText(serializedString)
                    .then(function() {
                        console.log('Network data copied to clipboard successfully!');
                    })
                    .catch(function(error) {
                        console.error('Unable to copy network data to clipboard: ', error);
                    });
            }

            function identifyCyclicReferences(network) {
                const visitedNodes = {}; // Set to track visited nodes
                const cyclicReferences = []; // Array to store cyclic references

                // Traverse the network using DFS
                function dfs(node) {
                    visitedNodes[node.id] = true; // Mark node as visited

                    for (const connectedNode of node.links) {
                    if (visitedNodes[connectedNode.id]) {
                        // Detect cyclic reference
                        cyclicReferences.push([node.id, connectedNode.id]);
                        return true; // Stop traversing
                    } else if (dfs(connectedNode)) {
                        return true; // Stop traversing if a cyclic reference is detected
                    }
                    }

                    return false; // No cyclic reference found
                }

                // Perform DFS for all nodes
                for (const node of network.nodes) {
                    if (!visitedNodes[node.id] && dfs(node)) {
                    break; // Stop after detecting the first cyclic reference
                    }
                }
                return cyclicReferences;
            }

            function createLoopNode(cyclicReference) {
                const loopNode = {
                    id: 'loop_' + new Date().getTime(), // Generate a unique ID for the loop node
                    label: 'Cyclic Loop', // Set a descriptive label
                    nodes: cyclicReference, // Store the nodes involved in the loop
                    incoming: [], // Create empty connections arrays
                    outgoing: [],
                };
                return loopNode;
            }

            function updateNodeConnections(cyclicReference, loopNode) {
                // Extract nodes involved in the loop
                const [node1, node2] = cyclicReference;

                // Update connections for node 1
                node1.incoming.forEach((connection) => {
                    if (connection.to.id === node2.id) {
                    connection.to = loopNode;
                    }
                });

                node1.outgoing.forEach((connection) => {
                    if (connection.from.id === node2.id) {
                    connection.from = loopNode;
                    }
                });

                // Update connections for node 2
                node2.incoming.forEach((connection) => {
                    if (connection.to.id === node1.id) {
                    connection.to = loopNode;
                    }
                });

                node2.outgoing.forEach((connection) => {
                    if (connection.from.id === node1.id) {
                    connection.from = loopNode;
                    }
                });
            }

            function copyCyclicNetworkToClipboard(network) {
                // Identify and handle cyclic references
                const cyclicReferences = identifyCyclicReferences(network);
                for (const cyclicReference of cyclicReferences) {
                    // Represent the loop as a single node
                    const loopNode = createLoopNode(cyclicReference);
                    network.addNode(loopNode);

                    // Update node connections to connect to the loop node
                    updateNodeConnections(cyclicReference, loopNode);
                }
                // Convert network data to clipboard format
                const networkData = convertNetworkDataToClipboardFormat(network);
                // Set clipboard content
                setClipboardContent(networkData);
            }

            // function copyNetworkToClipboard(network) {
            //     document.addEventListener('copy', (event) => {
            //         const networkData = JSON.stringify(network); // Convert network data to JSON
            //         event.clipboardData.setData('text/plain', networkData); // Set clipboard content
            //         alert('Network copied to clipboard successfully!'); // Notify user
            //     });
            // }

            function drawCurrentSelection(pnode) {
                var pnodeId=pnode.id
                const expanded=!pnode.expanded;
                const visited = [];
                var stack = [];
                stack=[pnodeId];
                var clickedNode = nodes.get(pnodeId);
                
                nodes.update({id:pnodeId,expanded:expanded,
                    shape:expanded?'box':'big ellipse'});
                while(stack.length) {
                    const currentNode = stack.pop();
                    if(visited.includes(currentNode))
                        continue;
                    visited.push(currentNode);
                    if(currentNode!=pnodeId) {
                        nodes.update({id:currentNode,hidden:!expanded});
                        if(nodes.get(currentNode).expanded) {
                            for(const node of children[currentNode])
                                stack.push(gnodes[node].id);
                        }
                    } else {
                        for(const node of children[currentNode]) {
                            //if(viewMode || !viewMode && parents[node].length==1)
                            if(viewMode==0)
                                stack.push(gnodes[node].id);
                        }
                    }
                }
                network.fit({maxZoomLevel:0.4});
            }

            function incType(typeFrequency,type) {
                if(!(type in typeFrequency))
                    typeFrequency[type]=0
                typeFrequency[type]+=1;
            }

            function drawFilteredGraph(rootNodeLabel) {
                if(mode!==0)
                    return;
                const visited = [];
                var stack = [];
                if(rootNodeLabel in gnodes)
                    stack=[{node:gnodes[rootNodeLabel],depth:0}];
                    //stack=[gnodes[rootNodeLabel]];

                tmp_nodes=[];
                let tmp_edges=[];
                var numChildren=-1;
                var numParents=-1;
                var typeFrequency={};
                if(rootNodeLabel!=="") {
                    if(viewMode===0) {
                        while(stack.length) {
                            const currentNode = stack.pop();
                            if(visited.includes(currentNode['node'].label))
                                continue;
                            if(currentNode.label!=rootNodeLabel)
                                incType(typeFrequency,gnodes[currentNode['node'].label]['data']['type'])
                            numChildren+=1;
                            visited.push(currentNode['node'].label);
                            var clonedObject = { ...currentNode['node'], ...{'hidden':false,'expanded':true} };
                            tmp_nodes.push(clonedObject);
                            for(const node of children[currentNode['node'].label]) {
                                if(viewModeMaxDepth===0 || ((currentNode['depth']+1)<=viewModeMaxDepth))
                                    stack.push({node:gnodes[node],depth:currentNode['depth']+1});
                                // if(!viewMode) {
                                //     for(const n of parents[node])
                                //         stack.push(gnodes[n]);
                                // }
                            }
                            tmp_edges=tmp_edges.concat(children_edges[currentNode['node'].label]);
                        }
                    }
                    if(viewMode===1) {
                        while(stack.length) {
                            const currentNode = stack.pop();
                            if(visited.includes(currentNode['node'].label))
                                continue;
                            if(currentNode['node'].label!=rootNodeLabel)
                                incType(typeFrequency,gnodes[currentNode['node'].label]['data']['type'])
                            numParents+=1;
                            visited.push(currentNode['node'].label);
                            var clonedObject = { ...currentNode['node'], ...{'hidden':false,'expanded':true} };
                            tmp_nodes.push(clonedObject);
                            for(const node of parents[currentNode['node'].label]) {
                                //stack.push(gnodes[node]);
                                if(viewModeMaxDepth===0 || ((currentNode['depth']+1)<=viewModeMaxDepth))
                                    stack.push({node:gnodes[node],depth:currentNode['depth']+1});
                            }
                            tmp_edges=tmp_edges.concat(parents_edges[currentNode['node'].label]);
                        }
                    }
                    if(viewMode===2) {
                        // viewModeMaxDepth
                        while(stack.length) {
                            const currentNode = stack.pop();
                            if(visited.includes(currentNode['node'].label))
                                continue;
                            if(currentNode.label!=rootNodeLabel)
                                incType(typeFrequency,gnodes[currentNode['node'].label]['data']['type'])
                            numChildren+=1;
                            visited.push(currentNode['node'].label);
                            var clonedObject = { ...currentNode['node'], ...{'hidden':false,'expanded':true} };
                            tmp_nodes.push(clonedObject);
                            for(const node of children[currentNode['node'].label]) {
                                //stack.push(gnodes[node]);
                                if(viewModeMaxDepth===0 || ((currentNode['depth']+1)<=viewModeMaxDepth))
                                    stack.push({node:gnodes[node],depth:currentNode['depth']+1});
                                // if(!viewMode) {
                                //     for(const n of parents[node])
                                //         stack.push(gnodes[n]);
                                // }
                            }
                            tmp_edges=tmp_edges.concat(children_edges[currentNode['node'].label]);
                        }

                        for(const node of parents[rootNodeLabel]) {
                            //stack.push(gnodes[node]);
                            //if(viewModeMaxDepth>0)
                            stack.push({node:gnodes[node],depth:1});
                        }
                        tmp_edges=tmp_edges.concat(parents_edges[rootNodeLabel]);
                        numParents=0;
                        while(stack.length) {
                            const currentNode = stack.pop();
                            if(visited.includes(currentNode['node'].label))
                                continue;
                            if(currentNode['node'].label!=rootNodeLabel)
                                incType(typeFrequency,gnodes[currentNode['node'].label]['data']['type'])
                            numParents+=1;
                            visited.push(currentNode['node'].label);
                            var clonedObject = { ...currentNode['node'], ...{'hidden':false,'expanded':true} };
                            tmp_nodes.push(clonedObject);
                            for(const node of parents[currentNode['node'].label]) {
                                //stack.push(gnodes[node]);
                                if(viewModeMaxDepth===0 || ((currentNode['depth']+1)<=viewModeMaxDepth))
                                    stack.push({node:gnodes[node],depth:currentNode['depth']+1});
                            }
                            tmp_edges=tmp_edges.concat(parents_edges[currentNode['node'].label]);
                        }
                    }
                }
                if(verbose) {
                    console.log("nodes");
                    console.log(tmp_nodes);
                    console.log("edges");
                    console.log(tmp_edges);
                }                
                nodes = new vis.DataSet(tmp_nodes);
                edges = new vis.DataSet(tmp_edges);

                network.setData({ nodes: nodes, edges: edges });

                if(rootNodeLabel!=="") {
                    var msg;
                    if(viewMode==0)
                        msg=`=== In-Neighbours View\n\nNumber of incoming neighbours=${numChildren}`
                    else if(viewMode==1)
                        msg=`=== Out-Neighbours View\n\nNumber of outgoing neighbours=${numParents}`
                    else
                        msg=`=== InOut-Neighbours View\n\nNumber of incoming neighbours=${numChildren}\nNumber of outgoing neighbours=${numParents}`
                    if(Object.keys(typeFrequency).length>0)
                        msg+="\n\n"
                    for(const type in  typeFrequency)
                        msg+=`.. '${type}'=${typeFrequency[type]}\n`
                    if(Object.keys(typeFrequency).length>0)
                        msg+="\n"
                    else
                        msg+="\n\n"
                    
                    nodes.update({
                        id:rootNodeLabel,
                        title:`${msg}${gnodes[rootNodeLabel]['title']}`,
                        borderWidth:2,
                        heightConstraint: {
                                minimum: 200
                        },
                        widthConstraint: {
                            minimum: 300,
                            maximum: 300
                        },
                        color: {
                            border:'red'
                        }
                    });
                }
                
                if(layoutDirection==='')
                    network.once("stabilized", function() {
                        network.fit({ maxZoomLevel: 0.4 });
                    });
                    /*setTimeout(function() {
                        network.fit({maxZoomLevel:0.4});
                        lastZoomPosition = network.getViewPosition();
                    },500);*/
                else {
                    network.fit({maxZoomLevel:0.4});
                    lastZoomPosition = network.getViewPosition();
                }
            }
            
            $(document).ready(function() {
                $('#select-type').select2({
                    dropdownCssClass :'typedrop'
                });                
                $('#select-need-id2').select2();
                $("#select-need-id").select2({
                    //width: '100%' // need to override the changed default
                    dropdownCssClass : 'bigdrop',
                });
                initSelectFilter();
            });

            const textBox = document.getElementById('input');

            $("#input").focus(function(){
                processingInputFilter=true;
                textBox.style.width = '100%';
                textBox.style.zIndex = 10;
                textBoxEditingActive=true;
                $('#mynetwork').css('opacity','0.5');
                /*$('#mynetwork').css({
                    'border': '5px solid red',
                    'padding': '10px'
                });*/
                //$('#input').attr("class","input-active");
                $('#input').removeClass('input-inactive').addClass('input-active');
                if(network!=null)
                    network.setOptions({ interaction: { keyboard: false } });
                console.log(`$("#input").focus(function())`)
            });

            $("#input").blur(function() {
                /*
                processingInputFilter=false;
                $('#mynetwork').css('opacity','1.0');
                //$('#mynetwork').css('border','none');
                $('#mynetwork').focus();

                $('.vis-network').focus();
                $('.vis-network').trigger($.Event('keydown', { key: 'Enter' }));
                //$('#mynetwork').trigger($.Event('keydown', { key: 'Enter' }));
                */
                return;
                var textBox = $(this);
                var text=$(this).val().trim(); // Get the text content and remove leading/trailing whitespaces
                handleSelectTypeEvent();
                console.log(`$("#input").blur(function())`);
                //$(this).off('keydown',handleKeydown);
                if(network!=null) {
                    network.setOptions( saveOpt );
                }
            });

            function findOptionByText(select2Element,text) {
                return option = select2Element.find('option').filter(function() {
                        const curText=$(this).text().trim();
                        return curText === text.trim();
                    });
            }
            function printOption(option) {
                if (option.length > 0) {
                    console.log(`option.value=${option.val()}`);
                    console.log(`option.text=${option.text()}`);
                    console.log(`option.info=${option.data('info')}`);
                } else {
                    console.log(`The option is invalid and cannot be printed`);
                }
            }
            function handleKeydown(e) {
                console.log('handleKeydown()',e.key,e.keyCode);
                //e.preventDefault();
                if (event.ctrlKey && event.key === 'c') {
                    e.preventDefault();
                    console.log('Ctrl+C pressed (copy)');
                    $('#input').val($('#select-filter').val());
                } else
                if (e.key === 'Escape') {
                    suggestionsList.innerHTML = "";
                    e.preventDefault();
                    if(mode==0) {
                        $('.vis-network').focus();
                        $('.vis-network').trigger($.Event('keydown', { key: 'Enter' }));
                    } else
                    if(mode==1) {
                        $('#mynetwork').focus();
                        $('#mynetwork').trigger($.Event('keydown', { key: 'Enter' }));
                    }
                    else
                    if(mode==2) {
                        $('#mynetwork').focus();
                        $('#mynetwork').trigger($.Event('keydown', { key: 'Enter' }));
                    }
                    processingInputFilter=false;
                    $('#mynetwork').css('opacity','1.0');
                } else
                if (e.key === 'Enter') {
                    console.log("'Enter' pressed");
                    suggestionsList.innerHTML = "";
                    var newText = $('#input').val().trim();
                    if(newText!=='') {
                        var selectedValue = $('#select-filter').val();
                        var selectedOption = $('#select-filter').select2('data')[0];
                        //printOption(selectedOption);
                        const option = findOptionByText($("#select-filter"),"Select");
                        //printOption(option);
                        newOption=findOptionByText($("#select-filter"),newText);
                        if (newOption.length > 0) {
                            //console.log("Option with text '" + newText + "' already exists.");
                            setCurrentSelectionByText(newText);
                        } else {
                            console.log("Option with text '" + newText + "' does not exist.");
                            if(newOption.length>0) {
                                //$('#select-filter option[value=`selectedValue`]').text(newText);
                                setCurrentSelectionByText(newText);
                                $('#select-filter option').filter(function () {
                                    return $(this).text() === 'Select';
                                }).remove();
                                $('#select-filter').trigger('change.select2');
                            } else {
                                userInput=newText;
                                task();
                            }
                        }
                        initSelectFilter();
                        handleSelectTypeEvent();
                    } else
                        handleSelectTypeEvent();
                    e.preventDefault();
                    if(mode==0) {
                        $('.vis-network').focus();
                        $('.vis-network').trigger($.Event('keydown', { key: 'Enter' }));
                    }
                    else
                    if(mode==1) {
                        $('#mynetwork').focus();
                        $('#mynetwork').trigger($.Event('keydown', { key: 'Enter' }));
                    }
                    else
                    if(mode==2) {
                        $('#mynetwork').focus();
                        $('#mynetwork').trigger($.Event('keydown', { key: 'Enter' }));
                    }
                    processingInputFilter=false;
                    $('#mynetwork').css('opacity','1.0');
                }  else {
                    const phrase = $('#input').val();
                    const suggestions = [];

                    const currentWord = phrase.split(new RegExp(`[${autocompletionDelimiters.join("\\")}]`)).pop();
                    const regex = new RegExp("^" + currentWord, "i");
                    for (const word of autocompletionAttributes) {
                        if (regex.test(word)) {
                            suggestions.push(word);
                            //console.log(`suggestion=${word}`)
                        }
                    }
                    suggestionsList.innerHTML = "";
                    for (const suggestion of suggestions) {
                        const listItem = document.createElement("li");
                        listItem.textContent = suggestion;
                        listItem.addEventListener("click", function () {
                            console.log(`currentWord=${currentWord}`);
                            console.log(`phrase=${phrase.replace(/\\/g,"")}`);
                            const regex = new RegExp(`${currentWord}$`);
                            const regex2 = new RegExp(`[ \t]+.*$`);
                            //input.value = phrase.replace(regex,"").replace(/\\/g,"") + suggestion;
                            var inputField = $('#input');
                            inputField.val(phrase.replace(regex,"").replace(/\\/g,"") + suggestion.replace(regex2,""));
                        });
                        suggestionsList.appendChild(listItem);
                    }
                }
            }
            
            $('#input').on('keydown',handleKeydown);
            $(window).resize(handleResize);

            $(document).keydown(function(event) {
                if (event.keyCode === 112 || event.key === 'F1') {
                    network.setOptions({ interaction: { keyboard: false } });
                    $('#helpModal').css('display', 'block').scrollTop(0);
                    event.preventDefault();
                    return;
                }
                if (event.key === 'Escape' || event.keyCode === 27) {
                    event.preventDefault();
                    if ($('#helpModal').is(':visible')) {
                        $('#helpModal').hide();
                        setTimeout(function() {
                            network.setOptions({ interaction: { keyboard: true } });
                        }, 1000);
                    }
                    return;
                }
            });

            function textExists(text) {
                var exists = false;
                $('#select-filter option').each(function () {
                    if ($(this).text().trim() === text.trim()) {
                        exists = true;
                        return false;
                    }
                });
                return exists;
            }

            function initSelectFilter() {
                $('#select-filter').select2({
                    dropdownCssClass: 'bigdropFilter',
                    allowClear: true,
                    placeholder: 'Filters',
                    language: {
                    noResults: function () {
                        return `<button style="width: 100%" type="button"
                            class="btn btn-primary" 
                            onClick='task()'>+ Add New Item</button>
                            </li>`;
                    }
                    },
                    escapeMarkup: function (markup) {
                    return markup;
                    }
                });

                $('#select-filter').on('select2:open', function () {
                    $('.select2-search__field').on('input', function () {
                    userInput = $(this).val();
                    });
                });

                // Event listener to handle removal of options
                $('#select-filter').on('select2:unselecting', function (e) {
                    var removedOption = $(e.params.args.data.element);
                    removedOption.remove(); // Remove the option from the dropdown
                });

                $('#select-filter').on('select2:select', function (e) {
                    const selectedOption = e.params.data;
                    const selectedValue = selectedOption.id; // Access option ID if needed
                    const selectedText = selectedOption.text;

                    var inputField = $('#input');
                    inputField.val(selectedText);
                    console.log('select2:select',selectedText)
                    handleSelectTypeEvent();
                });
                if(filters!=null) {
                    for(item of filters) {
                        $('#select-filter').append($('<option>', {
                            value: item,
                            text: item
                        }));
                    }
                    $('#select-filter').trigger('change.select2')
                    filters=null;
                }
            }

            function setCurrentSelectionByText(text) {
                $('#select-filter option').each(function () {
                    if ($(this).text().trim() === text.trim()) {
                        $('#select-filter').val($(this).val()).trigger('change.select2');
                        return false;
                    }
                });
            }

            function task(updateInput=true) {
                console.log(userInput);
                if (userInput) {
                    $('#select-filter').append($('<option>', {
                    value: userInput,
                    text: userInput
                    })).trigger('change.select2');
                    $('#select-filter').val(userInput).trigger('change.select2');
                    if(updateInput) {
                        var inputField = $('#input');
                        inputField.val(userInput);
                        initSelectFilter();
                        handleSelectTypeEvent();
                    }
                }
            }
        </script>
    </body>
</html>
